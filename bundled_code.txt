
================================================================================
BEGIN JAVASCRIPT/JSX FILES
================================================================================


// ========================================
// File: simplified-ui/src/components/AudioVisualizer.jsx
// ========================================

import React, {
    useRef,
} from "react";


const AudioVisualizer = ({ isRecording, audioContext, stream }) => {
    const canvasRef = useRef(null);
    const animationFrameRef = useRef(null);
    const audioSourceRef = useRef(null);
    const analyzerRef = useRef(null);

    React.useEffect(() => {
        if (!isRecording || !stream || !audioContext) return;

        const canvas = canvasRef.current;
        const ctx = canvas.getContext("2d");
        analyzerRef.current = audioContext.createAnalyser();
        analyzerRef.current.fftSize = 256;
        audioSourceRef.current = audioContext.createMediaStreamSource(stream);
        audioSourceRef.current.connect(analyzerRef.current);

        const bufferLength = analyzerRef.current.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        const draw = () => {
            if (!isRecording) return;
            animationFrameRef.current = requestAnimationFrame(draw);
            analyzerRef.current.getByteFrequencyData(dataArray);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();

            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            gradient.addColorStop(0, "#60a5fa");
            gradient.addColorStop(0.5, "#3b82f6");
            gradient.addColorStop(1, "#60a5fa");

            for (let i = 0; i < bufferLength; i++) {
                const x = (i / bufferLength) * canvas.width;
                const amplitude = dataArray[i] * 0.5;
                const y = canvas.height / 2 + Math.sin(i * 0.1) * amplitude;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 2;
            ctx.stroke();
        };

        draw();

        return () => {
            if (animationFrameRef.current)
                cancelAnimationFrame(animationFrameRef.current);
            if (audioSourceRef.current) audioSourceRef.current.disconnect();
        };
    }, [isRecording, stream, audioContext]);

    return (
        <canvas
            ref={canvasRef}
            className="w-full h-32 bg-background/50 backdrop-blur-sm rounded-lg border border-border/50"
            width={500}
            height={128}
        />
    );
};


export default AudioVisualizer;


// ========================================
// File: simplified-ui/src/components/BranchNode.jsx
// ========================================

import React, { useState, useEffect, useRef } from 'react';
import { Card } from './ui/card';
import { Badge } from "./index";
import { ChevronDown, ChevronUp, X, PlusCircle, MessageCircle, Timer, Edit2, Maximize2 } from 'lucide-react';
import { RecordingButton } from './RecordingButton';
import { cn } from './lib/utils';
import { motion, AnimatePresence } from 'framer-motion';

const generateThreadColor = (seed) => {
    const hues = [210, 330, 160, 280, 40, 190];
    const index = Math.abs(Math.floor(Math.sin(seed) * hues.length));
    return `hsl(${hues[index]}, 85%, 45%)`;
};

const calculateMessageOffset = (messages, index) => {
    return messages.slice(0, index + 1).reduce((acc, _, i) => (
        acc + (messages[i].content.length > 150 ? 160 : 120)
    ), 100);
};


const MessageTimestamp = ({ messageIndex, side = 'right' }) => {
    const baseTime = new Date();
    const offsetMinutes = messageIndex * 2;
    baseTime.setMinutes(baseTime.getMinutes() - offsetMinutes);

    const hours = baseTime.getHours().toString().padStart(2, '0');
    const minutes = baseTime.getMinutes().toString().padStart(2, '0');

    return (
        <div
            className={cn(
                "absolute flex items-center px-4 gap-1",
                "text-xs font-mono text-muted-foreground/50 hover:text-muted-foreground",
                "transition-colors duration-200",
                side === 'right'
                    ? "left-[calc(100%+16px)] top-4" // Align to top-right of message
                    : "right-[calc(100%+16px)] top-4"  // Align to top-left of message
            )}
        >
            <Timer className="w-3 h-3" />
            <span>{hours}:{minutes}</span>
        </div>
    );
};


const ExpandButton = ({ isExpanded, onClick }) => (
    <button
        onClick={(e) => {
            e.stopPropagation();
            onClick();
        }}
        className="inline-flex items-center gap-1 text-xs text-muted-foreground hover:text-foreground transition-colors"
    >
        {isExpanded ? <ChevronUp size={14} /> : <ChevronDown size={14} />}
    </button>
);

export const BranchNode = ({
    node,
    nodes,
    isExpanded,
    isSelected,
    onToggleExpand,
    onSelect,
    onDelete,
    onDragStart,
    onCreateBranch,
    selectedModel,
    currentMessageIndex,
    style,
    branchId,
    onUpdateTitle
}) => {
    const [isRecording, setIsRecording] = useState(null);
    const [expandedMessage, setExpandedMessage] = useState(null);
    const [isEditing, setIsEditing] = useState(false);
    const [titleInput, setTitleInput] = useState(node.title || '');
    const [showTitlePrompt, setShowTitlePrompt] = useState(!node.title);
    const titleInputRef = useRef(null);
    const [expandedModal, setExpandedModal] = useState(null);


    const generateTitle = async () => {
        try {
            const messages = node.messages.slice(0, 3); // Use first 3 messages for context
            const prompt = `Based on this conversation, suggest a concise and descriptive title (max 5 words):\n\n${messages.map(m => `${m.role}: ${m.content}`).join('\n')
                }`;

            const response = await fetch('http://localhost:11434/api/generate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: selectedModel,
                    prompt,
                    system: "You are a helpful assistant. Respond only with the title - no explanations or additional text.",
                    stream: false
                })
            });

            const data = await response.json();
            const generatedTitle = data.response.trim();
            handleTitleUpdate(generatedTitle);
        } catch (error) {
            console.error('Error generating title:', error);
        }
    };

    const handleTitleUpdate = (newTitle) => {
        onUpdateTitle(node.id, newTitle);
        setTitleInput(newTitle);
        setIsEditing(false);
        setShowTitlePrompt(false);
    };

    const renderTitle = () => {
        if (isEditing) {
            return (
                <input
                    ref={titleInputRef}
                    value={titleInput}
                    onChange={(e) => setTitleInput(e.target.value)}
                    onBlur={() => handleTitleUpdate(titleInput)}
                    onKeyDown={(e) => {
                        if (e.key === 'Enter') {
                            handleTitleUpdate(titleInput);
                        }
                    }}
                    className="bg-background px-2 py-1 rounded border border-border focus:outline-none focus:ring-2 focus:ring-ring"
                    placeholder="Enter title..."
                    autoFocus
                />
            );
        }

        return (
            <div className="flex items-center gap-2">
                <span className="text-lg font-semibold text-foreground">
                    {node.title || "Untitled Thread"}
                </span>
                <button
                    onClick={(e) => {
                        e.stopPropagation();
                        setIsEditing(true);
                    }}
                    className="p-1 rounded-full hover:bg-muted/80 transition-colors"
                >
                    <Edit2 className="w-4 h-4 text-muted-foreground" />
                </button>
            </div>
        );
    };

    const sendMessageToLLM = async (message) => {
        try {
            const response = await fetch('http://localhost:11434/api/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: selectedModel,
                    messages: [...node.messages, { role: 'user', content: message }],
                    stream: false,
                    options: {}
                })
            });
            const data = await response.json();
            return data.message;
        } catch (error) {
            console.error('Error sending message:', error);
            return null;
        }
    };

    const getThreadInfo = () => {
        let currentNode = node;
        const threadChain = [];

        while (currentNode) {
            threadChain.unshift({
                id: currentNode.id,
                color: generateThreadColor(currentNode.id),
                messageCount: currentNode.messages.length
            });
            currentNode = nodes.find(n => n.id === currentNode.parentId);
        }

        return threadChain;
    };

    const threadInfo = getThreadInfo();
    const mainColor = threadInfo[threadInfo.length - 1].color;
    const nodeKey = `node-${node.id}-${branchId || '0'}`;

    const handleTranscriptionComplete = async (transcript, index) => {
        setIsRecording(null);
        if (!transcript.trim()) return;

        const messages = [
            ...node.messages.slice(0, index + 1),
            { role: 'user', content: transcript }
        ];

        const aiResponse = await sendMessageToLLM(transcript);
        if (aiResponse) {
            messages.push(aiResponse);
        }

        const newPosition = {
            x: node.x + 300,
            y: node.y + calculateMessageOffset(node.messages, index) - 60
        };

        onCreateBranch(node.id, index, {
            ...newPosition,
            initialMessage: transcript,
            messages: messages,
            branchId: `${node.branchId || '0'}.${index}`
        });
    };

    const getMessageStyles = (index, totalMessages) => {
        const threadInfo = getThreadInfo();
        const mainColor = threadInfo[threadInfo.length - 1].color;

        return {
            background: `linear-gradient(to right, ${mainColor}10, ${mainColor}25)`,
            borderLeft: `4px solid ${mainColor}`,
            borderRadius: '0.5rem',
            position: 'relative',
            transition: 'box-shadow 0.3s ease',
            boxShadow: currentMessageIndex === index ? `0 0 10px 2px ${mainColor}` : 'none',
        };
    };

    const MessageModal = ({ message, isOpen, onClose }) => {
        if (!isOpen || !message) return null;

        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center">
                <div
                    className="absolute inset-0 bg-black/30 backdrop-blur-sm"
                    onClick={onClose}
                />
                <div className="w-[80vw] h-[60vh] bg-background rounded-lg shadow-lg z-50 overflow-auto p-6 relative">
                    <button
                        onClick={onClose}
                        className="absolute top-4 right-4 p-2 rounded-full hover:bg-muted/80"
                    >
                        <X className="w-5 h-5" />
                    </button>
                    <div className="prose dark:prose-invert max-w-none">
                        <div className="flex items-center gap-2 mb-4">
                            <Badge variant={message.role === 'user' ? 'default' : 'secondary'} className="text-base">
                                {message.role === 'user' ? 'You' : 'AI'}
                            </Badge>
                        </div>
                        {message.content}
                    </div>
                </div>
            </div>
        );
    };

    const renderMessages = () => {

        if (!isExpanded) return null;

        const allMessages = node.streamingContent
            ? [...node.messages, { role: 'assistant', content: node.streamingContent, isStreaming: true }]
            : node.messages;

        return (
            <>
                <div className="space-y-4">
                    {allMessages.map((msg, i) => (
                        <div
                            key={i}
                            className={cn(
                                "relative group",
                                currentMessageIndex === i && "ring-2 ring-primary"
                            )}
                            style={getMessageStyles(i, allMessages.length)}
                        >
                            <MessageTimestamp messageIndex={i} side={node.type === 'branch' ? 'left' : 'right'} />
                            <div className="p-4 relative z-10">
                                <div className="flex items-center justify-between mb-2">
                                    <div className="flex items-center gap-2">
                                        <Badge variant={msg.role === 'user' ? 'default' : 'secondary'} className="text-xs">
                                            {msg.role === 'user' ? 'You' : msg.isStreaming ? 'AI Typing...' : 'AI'}
                                        </Badge>
                                        <span className="text-sm font-medium text-muted-foreground">
                                            msg {i + 1} of {allMessages.length}
                                        </span>
                                    </div>
                                    <div className="flex items-center gap-2">
                                        {!msg.isStreaming && (
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    setExpandedModal(i);
                                                }}
                                                className="p-1.5 rounded-full hover:bg-muted/80 transition-colors"
                                            >
                                                <Maximize2 className="w-4 h-4 text-muted-foreground" />
                                            </button>
                                        )}
                                        {msg.content.length > 150 && !msg.isStreaming && (
                                            <ExpandButton
                                                isExpanded={expandedMessage === i}
                                                onClick={() => setExpandedMessage(expandedMessage === i ? null : i)}
                                            />
                                        )}
                                    </div>
                                </div>
                                <div className={cn(
                                    "text-sm text-foreground whitespace-pre-wrap",
                                    !msg.isStreaming && expandedMessage !== i && msg.content.length > 150 && "line-clamp-2"
                                )}>
                                    {msg.content}
                                    {msg.isStreaming && (
                                        <span className="inline-flex items-center gap-1 ml-1">
                                            <span className="w-1 h-1 bg-primary rounded-full animate-ping"></span>
                                            <span className="w-1 h-1 bg-primary rounded-full animate-ping delay-75"></span>
                                            <span className="w-1 h-1 bg-primary rounded-full animate-ping delay-150"></span>
                                        </span>
                                    )}
                                </div>
                                {!msg.isStreaming && (
                                    <div className="mt-3 flex items-center gap-3 opacity-0 group-hover:opacity-100 transition-opacity">
                                        <button
                                            className="flex items-center gap-2 text-sm text-primary hover:underline"
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                onCreateBranch(node.id, i, {
                                                    x: node.x + 300,
                                                    y: node.y + calculateMessageOffset(allMessages, i) - 60
                                                });
                                            }}
                                        >
                                            <PlusCircle className="w-4 h-4" />
                                            Branch from here
                                        </button>
                                        <RecordingButton
                                            variant="branch"
                                            onTranscriptionComplete={(transcript) => handleTranscriptionComplete(transcript, i)}
                                            onRecordingStart={() => setIsRecording(i)}
                                            onRecordingStop={() => setIsRecording(null)}
                                            className={cn(
                                                "transition-colors",
                                                isRecording === i && "text-destructive animate-pulse"
                                            )}
                                        />
                                    </div>
                                )}
                            </div>
                        </div>
                    ))}
                </div>

                <AnimatePresence>
                    <MessageModal
                        message={allMessages[expandedModal]}
                        isOpen={expandedModal !== null}
                        onClose={() => setExpandedModal(null)}
                    />
                </AnimatePresence>
            </>
        );
    };

        useEffect(() => {
        // Show title prompt for new nodes
        if (node.messages.length === 0) {
            setShowTitlePrompt(true);
        }
        // Generate title after a few messages if still untitled
        else if (node.messages.length >= 2 && !node.title) {
            generateTitle();
        }
    }, [node.messages.length, node.title]);

    return (
        <div
            className="absolute transition-all z-2 duration-200"
            style={style}
            data-node-id={node.id}
            key={nodeKey}
        >
            <Card
                className={cn(
                    "branch-node relative",
                    "bg-background/25 backdrop-blur supports-[backdrop-filter]:bg-background/20",
                    "border-2",
                    "hover:shadow-lg transition-all duration-300",
                    isSelected && "ring-2 ring-primary",
                    node.type !== 'main' ? "cursor-move" : "cursor-default"
                )}
                style={{
                    borderColor: mainColor,
                    maxWidth: '600px',
                    transform: style?.transform || 'none'
                }}
                onClick={(e) => {
                    e.stopPropagation();
                    onSelect();
                }}
                onMouseDown={(e) => {
                    if (node.type !== 'main') {
                        e.stopPropagation();
                        onDragStart(e, node);
                    }
                }}
            >
                <div className="p-4">
                    <div className="flex items-center justify-between mb-4">
                        <div className="flex items-center gap-3">
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onToggleExpand();
                                }}
                                className="p-2 rounded-full hover:bg-muted/80 transition-colors"
                            >
                                <ChevronDown
                                    className={cn(
                                        "w-5 h-5 transition-transform duration-200",
                                        !isExpanded && "-rotate-90"
                                    )}
                                    style={{ color: mainColor }}
                                />
                            </button>
                            <div className="flex flex-col">
                                {renderTitle()}
                                {showTitlePrompt && !isEditing && (
                                    <span className="text-xs text-muted-foreground mt-1">
                                        Click the edit icon to set a title, or wait for auto-generation
                                    </span>
                                )}
                                <div className="flex items-center gap-2 mt-1">
                                    <MessageCircle className="w-4 h-4 text-muted-foreground" />
                                    <span className="text-sm text-muted-foreground">
                                        {node.messages.length} messages
                                    </span>
                                </div>
                            </div>
                        </div>
                        {node.type !== 'main' && (
                            <button
                                className="p-2 rounded-full hover:bg-destructive/10 text-muted-foreground hover:text-destructive transition-colors"
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onDelete();
                                }}
                            >
                                <X className="w-5 h-5" />
                            </button>
                        )}
                    </div>
                    {renderMessages()}

                    {!isExpanded && node.messages.length > 0 && (
                        <div className="mt-2 text-sm text-muted-foreground">
                            <div className="line-clamp-2">
                                Last message: {
                                    node.streamingContent ||
                                    node.messages[node.messages.length - 1].content
                                }
                            </div>
                        </div>
                    )}
                </div>
            </Card>
        </div>
    );
};

export default BranchNode;


// ========================================
// File: simplified-ui/src/components/CanvasToolbar.jsx
// ========================================

import React from 'react';
import { MousePointer, Hand, Sun, Moon, Laptop, Palette, Bot } from 'lucide-react';
import { cn } from './lib/utils';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "./ui/dropdown-menu"

const tools = [
  { id: 'select', icon: MousePointer, label: 'Select and move threads (S)' },
  { id: 'pan', icon: Hand, label: 'Pan canvas (H)' }
];

const ToolButton = ({ tool, isActive, onClick }) => {
  const Icon = tool.icon;
  
  return (
    <div className="relative group">
      <button
        onClick={() => onClick(tool.id)}
        className={cn(
          "p-2 rounded-lg transition-all duration-200",
          "hover:bg-secondary",
          isActive ? "bg-primary/20 text-primary" : "text-muted-foreground",
          "light:hover:bg-gray-100 dark:hover:bg-gray-800",
          "hextech-nordic:hover:bg-blue-900/20 hextech-nordic:active:bg-blue-800/30",
          "singed-theme:hover:bg-green-900/20 singed-theme:active:bg-green-800/30"
        )}
        title={tool.label}
      >
        <Icon className="w-5 h-5" />
      </button>
      <span className={cn(
        "absolute hidden group-hover:block",
        "left-14 top-1/2 -translate-y-1/2",
        "px-2 py-1 text-xs rounded whitespace-nowrap",
        "bg-popover text-popover-foreground",
        "shadow-md border border-border",
        "z-50"
      )}>
        {tool.label}
      </span>
    </div>
  );
};

const CanvasToolbar = ({
  activeTool,
  onToolSelect,
  theme,
  onThemeChange,
  selectedModel,
  models,
  onModelSelect,
  isModelDropdownOpen,
  setIsModelDropdownOpen,
  modelDropdownRef
}) => {
  // Function to handle dropdown open state
  const handleModelDropdownOpen = (open) => {
    setIsModelDropdownOpen(open);
  };

  return (
    <div className={cn(
      "flex flex-col gap-2 p-2 rounded-xl shadow-lg",
      "bg-background/80 backdrop-blur supports-[backdrop-filter]:bg-background/60",
      "border border-border"
    )}>
      {tools.map(tool => (
        <ToolButton
          key={tool.id}
          tool={tool}
          isActive={activeTool === tool.id}
          onClick={onToolSelect}
        />
      ))}
    </div>
  );
}

export default CanvasToolbar;


// ========================================
// File: simplified-ui/src/components/Card.jsx
// ========================================

import * as React from "react"

const Card = React.forwardRef(({ 
    className = "", 
    children, 
    ...props 
  }, ref) => {
    return (
      <div
        ref={ref}
        className={`
          bg-white 
          rounded-lg 
          border 
          shadow-sm 
          ${className}
        `}
        {...props}
      >
        {children}
      </div>
    );
  });
  
Card.displayName = "Card"

const CardHeader = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={`flex flex-col space-y-1.5 p-6 ${className}`}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={`text-2xl font-semibold leading-none tracking-tight ${className}`}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={`text-sm text-muted-foreground ${className}`}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef(({ className, ...props }, ref) => (
  <div ref={ref} className={`p-6 pt-0 ${className}`} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={`flex items-center p-6 pt-0 ${className}`}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter }


// ========================================
// File: simplified-ui/src/components/ChatContainer.jsx
// ========================================

import React, { useState, useRef, useEffect } from 'react';
import { Maximize2, Minimize2, ArrowLeftRight } from 'lucide-react';
import { cn } from './lib/utils';

const ChatContainer = ({ children, className }) => {
  const [size, setSize] = useState('collapsed');
  const [containerWidth, setContainerWidth] = useState(400);
  const containerRef = useRef(null);

  const sizeStyles = {
    collapsed: 'w-[240px] h-[30px] overflow-hidden',
    normal: 'w-[400px] h-[800px]',
    large: 'w-[1400px] h-[800px]',
  };

  useEffect(() => {
    const updateWidth = () => {
      if (containerRef.current) {
        setContainerWidth(containerRef.current.offsetWidth);
      }
    };

    updateWidth();
    window.addEventListener('resize', updateWidth);
    return () => window.removeEventListener('resize', updateWidth);
  }, [size]);

  const getNextSize = (currentSize) => {
    const sizes = ['collapsed', 'normal', 'large'];
    const currentIndex = sizes.indexOf(currentSize);
    return sizes[(currentIndex + 1) % sizes.length];
  };

  // Split children into ModelStatus and other components
  const childrenArray = React.Children.toArray(children);
  const modelStatus = childrenArray[0];
  const otherChildren = childrenArray.slice(1);

  // Clone ModelStatus with containerWidth prop
  const enhancedModelStatus = React.cloneElement(modelStatus, {
    containerWidth,
    className: "w-full" // Ensure ModelStatus takes full width
  });

  return (
    <div 
      ref={containerRef}
      className={cn(
        "absolute bottom-0 right-0 bg-background border border-border z-10",
        "transition-all duration-300 ease-in-out flex flex-col",
        sizeStyles[size],
        className
      )}
    >
      {/* Header with ModelStatus */}
      <div className="flex-shrink-0 border-b border-border relative bg-background z-20 w-full">
        <div className="relative flex items-center w-full">
          {/* ModelStatus container with padding for the button */}
          <div className="flex-1 pl-10 w-full">
            {enhancedModelStatus}
          </div>
          
          {/* Size toggle button */}
          <button 
            onClick={() => setSize(getNextSize(size))}
            className={cn(
              "absolute top-0 left-0 px-2 py-1 hover:bg-secondary/50",
              "transition-colors duration-200",
              size === 'collapsed' ? "h-full" : "h-[30px]"
            )}
          >
            {size === 'collapsed' ? (
              <Maximize2 className="h-4 w-4" />
            ) : size === 'large' ? (
              <Minimize2 className="h-4 w-4" />
            ) : (
              <ArrowLeftRight className="h-4 w-4" />
            )}
          </button>
        </div>
      </div>

      {/* Chat content */}
      <div className="flex-1 min-h-0 relative">
        {otherChildren}
      </div>
    </div>
  );
};

export default ChatContainer;



// ========================================
// File: simplified-ui/src/components/ChatInterface.jsx
// ========================================

import React, { useRef, useState, useEffect } from 'react';
import { ChevronUp, ChevronDown, Send, Loader2 } from 'lucide-react';
import { ChatMessage } from './ChatMessage';
import { RecordingButton } from './RecordingButton';
import { cn } from '../components/lib/utils';

const ScrollButtons = ({
  containerRef,
  showScrollTop,
  showScrollBottom,
  onScrollTop,
  onScrollBottom
}) => {
  if (!showScrollTop && !showScrollBottom) return null;

  return (
    <div className="absolute right-8 bottom-4 flex flex-col gap-2 z-20">
      {showScrollTop && (
        <button
          onClick={onScrollTop}
          className={cn(
            "p-2.5 rounded-full transition-all duration-300",
            "bg-background/90 backdrop-blur supports-[backdrop-filter]:bg-background/60",
            "border border-border hover:border-border/80",
            "shadow-lg hover:shadow-xl",
            "group"
          )}
          aria-label="Scroll to top"
        >
          <ChevronUp className={cn(
            "w-5 h-5",
            "text-muted-foreground group-hover:text-foreground",
            "transition-colors"
          )} />
        </button>
      )}

      {showScrollBottom && (
        <button
          onClick={onScrollBottom}
          className={cn(
            "p-2.5 rounded-full transition-all duration-300",
            "bg-background/90 backdrop-blur supports-[backdrop-filter]:bg-background/60",
            "border border-border hover:border-border/80",
            "shadow-lg hover:shadow-xl",
            "group"
          )}
          aria-label="Scroll to bottom"
        >
          <ChevronDown className={cn(
            "w-5 h-5",
            "text-muted-foreground group-hover:text-foreground",
            "transition-colors"
          )} />
        </button>
      )}
    </div>
  );
};

const ChatInterface = ({
  messages = [],
  input = '',
  isLoading = false,
  onInputChange,
  onSend,
  activeNode,
  streamingMessage,
  continuationCount
}) => {
  const messagesEndRef = useRef(null);
  const messagesContainerRef = useRef(null);
  const [expandedMessage, setExpandedMessage] = useState(null);
  const [showScrollTop, setShowScrollTop] = useState(false);
  const [showScrollBottom, setShowScrollBottom] = useState(false);
  const [isTranscribing, setIsTranscribing] = useState(false);
  const [lastMessageCount, setLastMessageCount] = useState(messages.length);

  const shouldAutoScroll = useRef(true);
  const isNearBottom = useRef(true);

  const scrollToBottom = (behavior = 'smooth') => {
    if (messagesContainerRef.current) {
      const scrollHeight = messagesContainerRef.current.scrollHeight;
      messagesContainerRef.current.scrollTo({
        top: scrollHeight,
        behavior
      });
    }
  };

  const scrollToTop = () => {
    messagesContainerRef.current?.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  };

  const handleScroll = () => {
    if (!messagesContainerRef.current) return;

    const { scrollTop, scrollHeight, clientHeight } = messagesContainerRef.current;
    const bottomThreshold = 100;
    const distanceFromBottom = scrollHeight - (scrollTop + clientHeight);

    // Update auto-scroll behavior based on user's scroll position
    isNearBottom.current = distanceFromBottom <= bottomThreshold;
    shouldAutoScroll.current = isNearBottom.current;

    setShowScrollTop(scrollTop > 100);
    setShowScrollBottom(distanceFromBottom > bottomThreshold);
  };

  const handleTranscriptionComplete = (transcript) => {
    onInputChange({ target: { value: transcript } });
    setIsTranscribing(false);
    // Auto send the transcribed message
    if (transcript.trim()) {
      onSend();
    }
  };

  const handleTranscriptionStart = () => {
    setIsTranscribing(true);
    onInputChange({ target: { value: '' } });
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (input.trim() && !isLoading && !isTranscribing) {
        onSend();
      }
    }
  };

  // Scroll handling for new messages and streaming
  useEffect(() => {
    if (messages.length !== lastMessageCount) {
      setLastMessageCount(messages.length);
      scrollToBottom('auto');
    }
  }, [messages, lastMessageCount]);

  useEffect(() => {
    if (streamingMessage && shouldAutoScroll.current) {
      scrollToBottom('auto');
    }
  }, [streamingMessage]);

  // Initial scroll button visibility
  useEffect(() => {
    handleScroll();
  }, [messages]);

  // Auto-expand latest message
  useEffect(() => {
    if (messages.length > 0) {
      setExpandedMessage(messages.length - 1);
    }
  }, [messages.length]);

  return (
    <div className="flex flex-col h-full">
      {/* Header */}
      <div className={cn(
        "flex-shrink-0 px-6 py-4 border-b border-border",
        "bg-background/80 backdrop-blur supports-[backdrop-filter]:bg-background/60",
        "sticky top-0 z-10"
      )}>
        <div className="flex items-center justify-between">
          <h2 className="font-semibold text-foreground">
            {activeNode?.title || 'Chat Thread'}
          </h2>
          <span className="text-sm text-muted-foreground">
            {activeNode?.type === 'main' ? 'Main Thread' : `Branch ${activeNode?.id}`}
          </span>
        </div>
      </div>

      {/* Messages Container */}
      <div className="flex-1 max-h-[100% -140px] relative">
        <div
          ref={messagesContainerRef}
          onScroll={handleScroll}
          className={cn(
            "absolute inset-0 overflow-y-auto",
            "px-6 py-6 space-y-4",
            "bg-background/50 backdrop-blur-sm"
          )}
        >
          {/* Messages */}
          <div className="space-y-4">
            {messages.map((message, i) => (
              <ChatMessage
                key={`${i}-${message.content}`}
                message={{
                  ...message,
                  isTranscribing: isTranscribing && i === messages.length - 1
                }}
                isCollapsed={expandedMessage !== i}
                onClick={() => setExpandedMessage(expandedMessage === i ? null : i)}
              />
            ))}

            {streamingMessage && (
              <ChatMessage
                message={{
                  role: 'assistant',
                  content: streamingMessage,
                  isStreaming: true,
                  continuationCount
                }}
                isCollapsed={false}
              />
            )}

            <div ref={messagesEndRef} />
          </div>

          {/* Scroll Buttons */}
          <ScrollButtons
            containerRef={messagesContainerRef}
            showScrollTop={showScrollTop}
            showScrollBottom={showScrollBottom}
            onScrollTop={scrollToTop}
            onScrollBottom={() => {
              shouldAutoScroll.current = true;
              scrollToBottom();
            }}
          />
        </div>
      </div>

      {/* Input Area */}
      <div className={cn(
        "flex-shrink-0 border-t border-border",
        "bg-background/80 backdrop-blur supports-[backdrop-filter]:bg-background/60",
        "px-4 py-3",
        "sticky bottom-0 z-10"
      )}>
        <div className="flex gap-3">
          <textarea
            value={input}
            onChange={onInputChange}
            onKeyDown={handleKeyDown}
            placeholder="Type your message..."
            rows={1}
            className={cn(
              "flex-1 px-4 py-3 rounded-xl resize-none",
              "bg-muted/50 border border-border",
              "focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent",
              "placeholder:text-muted-foreground",
              "transition-all duration-300",
              "disabled:opacity-50 disabled:cursor-not-allowed"
            )}
            disabled={isLoading || isTranscribing}
          />

          <RecordingButton
            onTranscriptionComplete={handleTranscriptionComplete}
            onTranscriptionStart={handleTranscriptionStart}
            onRecordingStop={() => setIsTranscribing(false)}
            disabled={isLoading}
          />

          <button
            onClick={() => {
              if (input.trim() && !isLoading && !isTranscribing) {
                onSend();
              }
            }}
            disabled={!input.trim() || isLoading || isTranscribing}
            className={cn(
              "px-5 py-3 rounded-xl transition-all duration-300",
              "bg-primary text-primary-foreground",
              "hover:bg-primary/90",
              "shadow-md hover:shadow-lg",
              "disabled:opacity-50 disabled:cursor-not-allowed"
            )}
          >
            {isLoading ? (
              <Loader2 className="w-5 h-5 animate-spin" />
            ) : (
              <Send className="w-5 h-5" />
            )}
          </button>
        </div>
      </div>
    </div>
  );
};

export default ChatInterface;


// ========================================
// File: simplified-ui/src/components/ChatMessage.jsx
// ========================================

import React, { useState, useEffect, useRef } from 'react';
import { Check, ChevronDown, Send, Loader2, ChevronUp, Sparkles, Play, Pause } from 'lucide-react';
import { cn } from '../components/lib/utils';

const API_URL = 'https://api.elevenlabs.io/v1/text-to-speech';
const TTS_CHUNK_SIZE = 1024;

// Utility functions
const splitIntoSentences = (text) => {
  return text.match(/[^.!?\n]+[.!?\n]+/g) || [text];
};

const createChunks = (sentences, maxChunkSize = TTS_CHUNK_SIZE) => {
  const chunks = [];
  let currentChunk = '';

  for (const sentence of sentences) {
    if ((currentChunk + sentence).length > maxChunkSize && currentChunk) {
      chunks.push(currentChunk.trim());
      currentChunk = '';
    }
    currentChunk += sentence;
  }

  if (currentChunk) {
    chunks.push(currentChunk.trim());
  }

  return chunks;
};

const renderContinuationIndicator = (message) => {
  if (!message.continuationCount) return null;

  return (
    <div className="text-xs font-medium text-muted-foreground mt-2 flex items-center gap-2">
      <div className="flex gap-1">
        {[...Array(message.continuationCount)].map((_, i) => (
          <Sparkles key={i} className="w-3 h-3 text-primary" />
        ))}
      </div>
      {message.continuationCount > 1 &&
        `${message.continuationCount} continuations`
      }
    </div>
  );
};

export const ChatMessage = ({
  message,
  isCollapsed,
  onClick,
  voiceId = "21m00Tcm4TlvDq8ikWAM",
  apiKey = "----"
}) => {
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentChunkIndex, setCurrentChunkIndex] = useState(0);
  const [audioQueue, setAudioQueue] = useState([]);
  const [playbackProgress, setPlaybackProgress] = useState(0);
  const audioRef = useRef(null);
  const chunksRef = useRef([]);

  // Determine if message needs to be collapsible
  const needsCollapse = message.content?.length > 150;
  const isStreaming = message.isStreaming || false;
  const isTranscribing = message.isTranscribing || false;

  const generateSpeechForChunk = async (text) => {
    try {
      const response = await fetch(`${API_URL}/${voiceId}`, {
        method: 'POST',
        headers: {
          'Accept': 'audio/mpeg',
          'Content-Type': 'application/json',
          'xi-api-key': apiKey
        },
        body: JSON.stringify({
          text,
          model_id: "eleven_monolingual_v1",
          voice_settings: {
            stability: 0.5,
            similarity_boost: 0.5
          }
        })
      });

      if (!response.ok) {
        throw new Error('Failed to generate speech');
      }

      const audioBlob = await response.blob();
      return URL.createObjectURL(audioBlob);
    } catch (error) {
      console.error('Error generating speech for chunk:', error);
      return null;
    }
  };

  const handlePlayPause = async () => {
    if (isPlaying) {
      audioRef.current?.pause();
      setIsPlaying(false);
      setCurrentChunkIndex(0);
      setAudioQueue([]);
      setPlaybackProgress(0);
    } else {
      setIsPlaying(true);

      // Initialize chunks if not already done
      if (chunksRef.current.length === 0) {
        const sentences = splitIntoSentences(message.content);
        chunksRef.current = createChunks(sentences);
      }

      // Generate audio for first chunk if queue is empty
      if (audioQueue.length === 0) {
        const audioUrl = await generateSpeechForChunk(chunksRef.current[0]);
        if (audioUrl) {
          setAudioQueue([audioUrl]);
          playChunk(audioUrl);
        }
      }
    }
  };

  const playChunk = (audioUrl) => {
    if (audioRef.current) {
      audioRef.current.src = audioUrl;
      audioRef.current.play();
    }
  };

  const handleAudioEnd = async () => {
    // Clean up current audio URL
    if (audioQueue[0]) {
      URL.revokeObjectURL(audioQueue[0]);
    }

    // Move to next chunk
    const nextChunkIndex = currentChunkIndex + 1;
    if (nextChunkIndex < chunksRef.current.length) {
      setCurrentChunkIndex(nextChunkIndex);

      // Generate audio for next chunk
      const nextAudioUrl = await generateSpeechForChunk(chunksRef.current[nextChunkIndex]);
      if (nextAudioUrl) {
        setAudioQueue([nextAudioUrl]);
        playChunk(nextAudioUrl);
      }

      // Update progress
      setPlaybackProgress(Math.round((nextChunkIndex / chunksRef.current.length) * 100));
    } else {
      // Reset everything when finished
      setIsPlaying(false);
      setCurrentChunkIndex(0);
      setAudioQueue([]);
      setPlaybackProgress(0);
    }
  };

  // Clean up audio URLs when component unmounts
  useEffect(() => {
    return () => {
      audioQueue.forEach(url => URL.revokeObjectURL(url));
    };
  }, [audioQueue]);

  // Reset state when message changes
  useEffect(() => {
    chunksRef.current = [];
    setCurrentChunkIndex(0);
    setPlaybackProgress(0);
    setIsPlaying(false);
    setAudioQueue([]);
  }, [message.content]);


  return (
    <div className={cn(
      "group relative p-6 rounded-2xl transition-all duration-300",
      "border border-transparent",
      !isStreaming && "hover:border-border hover:shadow-lg hover:shadow-background/5",
      message.role === 'user'
        ? "bg-primary/5 hover:bg-primary/10"
        : "bg-muted hover:bg-muted/80",
      needsCollapse && isCollapsed ? "cursor-pointer" : "",
      isTranscribing ? "animate-pulse" : "",
      "hextech-nordic:border-blue-500/20 hextech-nordic:hover:border-blue-500/40",
      "singed-theme:border-green-500/20 singed-theme:hover:border-green-500/40"
    )}>
      <div className="flex items-center gap-3 mb-3">
        <div className={cn(
          "flex items-start gap-2 text-xs font-medium px-3 py-1.5 rounded-full",
          "text-start", // Add text alignment
          message.role === 'user'
            ? "bg-primary text-primary-foreground"
            : "bg-secondary text-secondary-foreground"
        )}>
          <span className="whitespace-nowrap">
            {message.role === 'user' ? (
              message.isTranscribing ? 'Recording...' : 'You'
            ) : (
              <>
                <Sparkles className="inline-block w-3 h-3 mr-1" />
                {isStreaming ? 'AI Typing...' : 'AI'}
              </>
            )}
          </span>
        </div>

        {/* TTS controls for AI messages */}
        {message.role === 'assistant' && !isStreaming && (
          <button
            onClick={(e) => {
              e.stopPropagation();
              handlePlayPause();
            }}
            className={cn(
              "flex items-center gap-2 px-3 py-1.5 rounded-full",
              "text-xs font-medium transition-colors",
              "bg-primary/10 hover:bg-primary/20",
              "text-primary hover:text-primary-foreground"
            )}
          >
            {isPlaying ? (
              <>
                <Pause className="w-3 h-3" />
                Stop
              </>
            ) : (
              <>
                <Play className="w-3 h-3" />
                Play
              </>
            )}
          </button>
        )}

        <audio
          ref={audioRef}
          onEnded={handleAudioEnd}
          onError={() => {
            setIsPlaying(false);
            setCurrentChunkIndex(0);
            setAudioQueue([]);
            setPlaybackProgress(0);
          }}
        />

        {needsCollapse && (
          <div className={cn(
            "text-xs font-medium transition-colors",
            isCollapsed ? "text-primary hover:text-primary/80" : "text-muted-foreground"
          )}>
            {isCollapsed ? 'Expand message' : 'Collapse message'}
          </div>
        )}

        {isStreaming && (
          <div className="flex items-center gap-2">
            <div className="flex gap-1">
              {[...Array(3)].map((_, i) => (
                <span key={i} className={cn(
                  "animate-bounce w-1 h-1 rounded-full",
                  "bg-primary",
                  `delay-${i * 150}`
                )}></span>
              ))}
            </div>
          </div>
        )}
      </div>

      <div className={cn(
        "text-sm leading-relaxed whitespace-pre-wrap",
        "text-foreground",
        isCollapsed ? "line-clamp-3" : ""
      )}>
        {message.content}

        {isStreaming && !message.content && (
          <span className="text-muted-foreground italic">Generating response...</span>
        )}
      </div>

      {/* Playback progress */}
      {isPlaying && chunksRef.current.length > 0 && (
        <div className="mt-2 flex flex-col gap-1">
          <div className="text-xs text-muted-foreground">
            Playing chunk {currentChunkIndex + 1} of {chunksRef.current.length}
          </div>
          <div className="w-full h-1 bg-primary/20 rounded-full overflow-hidden">
            <div
              className="h-full bg-primary transition-all duration-200"
              style={{ width: `${playbackProgress}%` }}
            />
          </div>
        </div>
      )}

      {(!isStreaming && message.role === 'assistant') && renderContinuationIndicator(message)}

      {isStreaming && message.streamProgress && (
        <div className="mt-2 text-xs text-muted-foreground">
          Streaming... {message.streamProgress}%
        </div>
      )}
    </div>
  );
};

export default ChatMessage;

export const GlassPanel = ({ children, className = '', ...props }) => (
  <div
    className={cn(
      "bg-background/80 backdrop-blur-md",
      "border border-border",
      "shadow-lg shadow-background/5",
      className
    )}
    {...props}
  >
    {children}
  </div>
);

// ModelSelector component
export const ModelSelector = ({ selectedModel, models, onSelect, isLoading }) => {
  const [isOpen, setIsOpen] = useState(false);

  if (isLoading) return (
    <div className={cn(
      "h-10 w-64 rounded-lg animate-pulse flex items-center justify-center",
      "bg-muted"
    )}>
      <Loader2 className="w-5 h-5 text-muted-foreground animate-spin" />
    </div>
  );

  return (
    <div className="relative w-64">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={cn(
          "w-full flex items-center justify-between px-4 py-2.5 rounded-lg",
          "bg-background/90 border border-border",
          "shadow-sm hover:shadow-md transition-all duration-200"
        )}
      >
        <span className="font-medium text-foreground truncate">{selectedModel}</span>
        <ChevronDown className={cn(
          "w-4 h-4 text-muted-foreground transition-transform duration-200",
          isOpen ? "rotate-180" : ""
        )} />
      </button>

      {isOpen && (
        <div className={cn(
          "absolute mt-2 w-full py-1 z-50 rounded-lg",
          "bg-background/95 backdrop-blur-lg",
          "border border-border shadow-xl"
        )}>
          {models.map((model) => (
            <button
              key={model.name}
              onClick={() => {
                onSelect(model.name);
                setIsOpen(false);
              }}
              className={cn(
                "w-full flex items-center px-4 py-2.5 text-left",
                "hover:bg-muted/80 text-foreground"
              )}
            >
              {model.name === selectedModel && (
                <Check className="w-4 h-4 text-primary mr-2 shrink-0" />
              )}
              <span className={cn(
                "truncate",
                model.name === selectedModel ? "text-primary font-medium" : ""
              )}>
                {model.name}
              </span>
            </button>
          ))}
        </div>
      )}
    </div>
  );
};

const ModelLoadingState = () => (
  <div className="h-10 w-64 bg-gray-100 rounded-lg animate-pulse flex items-center justify-center">
    <Loader2 className="w-5 h-5 text-gray-400 animate-spin" />
  </div>
);





// ========================================
// File: simplified-ui/src/components/ChatPersistanceManager.jsx
// ========================================

import React, { useEffect, useState } from 'react';
import { Button } from './ui/button';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogClose
} from './ui/dialog';
import { ScrollArea } from './ui/scroll-area';
import { Input } from './ui/input';
import { Save, Trash2, FolderOpen } from 'lucide-react';
import axios from 'axios';

export const ChatPersistenceManager = ({
  nodes,
  onLoadChat,
  activeChat,
  setActiveChat
}) => {
  const [showLoadDialog, setShowLoadDialog] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [chatToDelete, setChatToDelete] = useState(null);
  const [savedChats, setSavedChats] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');

  const loadSavedChats = async () => {
    try {
      const response = await axios.get('http://localhost:5001/api/chats/list');
      if (response.data.success) {
        setSavedChats(response.data.chats);
      }
    } catch (error) {
      console.error('Error loading saved chats:', error);
    }
  };

  useEffect(() => {
    loadSavedChats();
  }, []);

  const handleSave = async () => {
    if (!nodes.length) return;

    setIsLoading(true);
    try {
      const chatData = {
        chatId: activeChat?.id || undefined,
        nodes,
        title: activeChat?.title || 'Untitled Chat',
        metadata: {
          nodeCount: nodes.length,
          messageCount: nodes.reduce((acc, node) => acc + node.messages.length, 0)
        }
      };

      const response = await axios.post('http://localhost:5001/api/chats/save', chatData);
      if (response.data.success) {
        setActiveChat({
          id: response.data.chatId,
          title: chatData.title
        });
        await loadSavedChats();
      }
    } catch (error) {
      console.error('Error saving chat:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleLoad = async (chatId) => {
    setIsLoading(true);
    try {
      const response = await axios.get(`http://localhost:5001/api/chats/load/${chatId}`);
      if (response.data.success) {
        const chatData = response.data.data;
        onLoadChat(chatData.nodes);
        setActiveChat({
          id: chatData.id,
          title: chatData.title
        });
        setShowLoadDialog(false);
      }
    } catch (error) {
      console.error('Error loading chat:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleDelete = async (chatId) => {
    try {
      const response = await axios.delete(`http://localhost:5001/api/chats/delete/${chatId}`);
      if (response.data.success) {
        await loadSavedChats();
        if (activeChat?.id === chatId) {
          setActiveChat(null);
        }
        setShowDeleteDialog(false);
        setChatToDelete(null);
      }
    } catch (error) {
      console.error('Error deleting chat:', error);
    }
  };

  const initiateDelete = (chat, e) => {
    e.stopPropagation();
    setChatToDelete(chat);
    setShowDeleteDialog(true);
  };

  const filteredChats = savedChats.filter(chat =>
    chat.title.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <>
      <div className="flex gap-2">
        <Button
          variant="outline"
          size="icon"
          onClick={handleSave}
          disabled={isLoading || !nodes.length}
          className="h-9 w-9"
        >
          <Save className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => setShowLoadDialog(true)}
          disabled={isLoading}
          className="h-9 w-9"
        >
          <FolderOpen className="h-4 w-4" />
        </Button>
      </div>

      {/* Load Dialog */}
      <Dialog open={showLoadDialog} onOpenChange={setShowLoadDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Load Chat</DialogTitle>
            <DialogDescription>
              Select a chat to load from your saved conversations
            </DialogDescription>
          </DialogHeader>

          <Input
            placeholder="Search chats..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="mb-4"
          />

          <ScrollArea className="h-[300px] pr-4">
            <div className="space-y-2">
              {filteredChats.map((chat) => (
                <div
                  key={chat.id}
                  className="flex items-center justify-between p-3 rounded-lg border hover:bg-accent cursor-pointer"
                  onClick={() => handleLoad(chat.id)}
                >
                  <div>
                    <h3 className="font-medium">{chat.title}</h3>
                    <p className="text-sm text-muted-foreground">
                      {new Date(chat.lastModified).toLocaleString()}
                    </p>
                  </div>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={(e) => initiateDelete(chat, e)}
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </div>
              ))}
            </div>
          </ScrollArea>
        </DialogContent>
      </Dialog>

      {/* Delete Confirmation Dialog */}
      <Dialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Delete Chat</DialogTitle>
            <DialogDescription>
              Are you sure you want to delete "{chatToDelete?.title}"? This action cannot be undone.
            </DialogDescription>
          </DialogHeader>
          <Dialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
            <DialogContent className="sm:max-w-[425px]">
              <DialogHeader>
                <DialogTitle>Delete Chat</DialogTitle>
                <DialogDescription>
                  Are you sure you want to delete "{chatToDelete?.title}"? This action cannot be undone.
                </DialogDescription>
              </DialogHeader>
              <div className="flex gap-2 justify-end mt-4">
                <DialogClose asChild>
                  <Button variant="outline">Cancel</Button>
                </DialogClose>
                <Button
                  variant="destructive"
                  onClick={() => chatToDelete && handleDelete(chatToDelete.id)}
                >
                  Delete
                </Button>
              </div>
            </DialogContent>
          </Dialog>
        </DialogContent>
      </Dialog>
    </>
  );
};

export default ChatPersistenceManager;


// ========================================
// File: simplified-ui/src/components/ChatUI.jsx
// ========================================

import React, {
    useState,
} from "react";
import {
    ArrowLeft,
} from "lucide-react";
import {
    Button,
    Input,
} from "./index";




const ChatUI = ({ topic, model, onBack }) => {
    const [messages, setMessages] = useState([
        { role: "system", content: `You are now discussing: ${topic}` },
    ]);
    const [input, setInput] = useState("");
    const [loading, setLoading] = useState(false);

    const sendMessage = async () => {
        if (!input.trim()) return;

        const newMessages = [...messages, { role: "user", content: input }];
        setMessages(newMessages);
        setInput("");
        setLoading(true);

        try {
            const response = await fetch("http://localhost:11434/api/chat", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    model: model || "qwen2.5-coder:7b",
                    messages: newMessages,
                    stream: false,
                }),
            });
            const data = await response.json();
            if (data.message?.content) {
                setMessages([
                    ...newMessages,
                    { role: "assistant", content: data.message.content },
                ]);
            }
        } catch (error) {
            console.error("Error during chat:", error);
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className="w-full max-w-2xl space-y-4">
            <div className="flex items-center justify-between">
                <h2 className="text-xl font-semibold">{topic}</h2>
                <Button variant="ghost" onClick={onBack}>
                    <ArrowLeft className="h-5 w-5" />
                    Back
                </Button>
            </div>
            <div className="border rounded-lg p-4 h-96 overflow-y-auto">
                {messages.map((msg, index) => (
                    <div
                        key={index}
                        className={`mb-4 ${msg.role === "user" ? "text-right" : "text-left"
                            }`}
                    >
                        <div
                            className={`inline-block px-4 py-2 rounded-lg ${msg.role === "user"
                                ? "bg-primary text-white"
                                : "bg-gray-200 text-black"
                                }`}
                        >
                            {msg.content}
                        </div>
                    </div>
                ))}
                {loading && (
                    <div className="text-left">
                        <div className="inline-block px-4 py-2 rounded-lg bg-gray-200 text-black">
                            Typing...
                        </div>
                    </div>
                )}
            </div>
            <div className="flex items-center gap-2">
                <Input
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    placeholder="Type your message..."
                    onKeyPress={(e) => {
                        if (e.key === "Enter") {
                            sendMessage();
                        }
                    }}
                />
                <Button onClick={sendMessage} disabled={loading}>
                    Send
                </Button>
            </div>
        </div>
    );
};


export default ChatUI;


// ========================================
// File: simplified-ui/src/components/ConversationFlowVis.jsx
// ========================================

import React, { useState, useCallback, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { GitBranch, MessageCircle, GitMerge } from 'lucide-react';

const ConversationFlowVis = ({ data }) => {
  const [selectedBranch, setSelectedBranch] = useState(null);
  const [hoveredNode, setHoveredNode] = useState(null);

  // Process data to create tree structure
  const treeData = useMemo(() => {
    if (!data) return null;
    
    // Create nodes map
    const nodesMap = new Map();
    const childrenMap = new Map();
    
    // First pass - create nodes
    data.forEach(msg => {
      nodesMap.set(msg.id, {
        ...msg,
        children: [],
        level: 0,
        x: 0,
        y: 0
      });
      
      // Track parent-child relationships
      if (msg.parentId) {
        if (!childrenMap.has(msg.parentId)) {
          childrenMap.set(msg.parentId, []);
        }
        childrenMap.get(msg.parentId).push(msg.id);
      }
    });
    
    // Second pass - build tree structure
    childrenMap.forEach((children, parentId) => {
      const parent = nodesMap.get(parentId);
      if (parent) {
        children.forEach(childId => {
          const child = nodesMap.get(childId);
          if (child) {
            parent.children.push(child);
            child.level = parent.level + 1;
          }
        });
      }
    });
    
    // Calculate positions
    const root = Array.from(nodesMap.values()).find(node => !node.parentId);
    if (!root) return null;
    
    const NODE_WIDTH = 200;
    const NODE_HEIGHT = 100;
    const LEVEL_GAP = 120;
    
    const positionNode = (node, x = 0, y = 0) => {
      node.x = x;
      node.y = y;
      
      // Position children
      const totalChildren = node.children.length;
      const childrenWidth = totalChildren * NODE_WIDTH;
      let startX = x - (childrenWidth / 2);
      
      node.children.forEach((child, index) => {
        positionNode(
          child,
          startX + (index * NODE_WIDTH) + (NODE_WIDTH / 2),
          y + LEVEL_GAP
        );
      });
    };
    
    positionNode(root);
    return root;
  }, [data]);

  // Render connections between nodes
  const renderConnections = useCallback((node) => {
    if (!node.children.length) return null;
    
    return node.children.map(child => {
      const path = `M ${node.x},${node.y + 30} 
                    C ${node.x},${node.y + 60}
                      ${child.x},${child.y - 30}
                      ${child.x},${child.y - 30}`;
                      
      return (
        <motion.path
          key={`${node.id}-${child.id}`}
          d={path}
          stroke={child.branchId === selectedBranch ? '#3b82f6' : '#e2e8f0'}
          strokeWidth="2"
          fill="none"
          initial={{ pathLength: 0 }}
          animate={{ pathLength: 1 }}
          transition={{ duration: 0.5 }}
        />
      );
    });
  }, [selectedBranch]);

  const renderNode = useCallback((node) => {
    const isActive = node.branchId === selectedBranch;
    const isHovered = hoveredNode?.id === node.id;
    
    return (
      <g key={node.id}>
        {/* Render connections */}
        {renderConnections(node)}
        
        {/* Render node */}
        <motion.g
          transform={`translate(${node.x - 60},${node.y - 30})`}
          onMouseEnter={() => setHoveredNode(node)}
          onMouseLeave={() => setHoveredNode(null)}
          onClick={() => setSelectedBranch(node.branchId)}
          whileHover={{ scale: 1.05 }}
          style={{ cursor: 'pointer' }}
        >
          {/* Node background */}
          <motion.rect
            width="120"
            height="60"
            rx="8"
            fill={isActive ? '#3b82f6' : '#ffffff'}
            stroke={isHovered ? '#3b82f6' : '#e2e8f0'}
            strokeWidth="2"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          />
          
          {/* Branch indicator */}
          {node.children.length > 0 && (
            <motion.g transform="translate(85, 10)">
              <GitBranch 
                size={16} 
                color={isActive ? '#ffffff' : '#94a3b8'}
              />
            </motion.g>
          )}
          
          {/* Message count */}
          <text
            x="60"
            y="35"
            textAnchor="middle"
            fill={isActive ? '#ffffff' : '#1e293b'}
            fontSize="14"
            fontWeight={isActive ? 'bold' : 'normal'}
          >
            {node.messages.length} messages
          </text>
        </motion.g>
        
        {/* Recursively render children */}
        {node.children.map(child => renderNode(child))}
      </g>
    );
  }, [selectedBranch, hoveredNode, renderConnections]);

  if (!treeData) return null;

  return (
    <div className="w-full h-full overflow-hidden bg-gray-50">
      <svg
        width="100%"
        height="100%"
        viewBox="-500 -50 1000 600"
        preserveAspectRatio="xMidYMid meet"
      >
        <g transform="translate(500,50)">
          {renderNode(treeData)}
        </g>
      </svg>
      
      {/* Branch info panel */}
      <AnimatePresence>
        {hoveredNode && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 20 }}
            className="absolute bottom-4 left-4 bg-white rounded-lg shadow-lg p-4 max-w-md"
          >
            <div className="flex items-center gap-2 mb-2">
              <MessageCircle className="w-4 h-4 text-gray-500" />
              <span className="font-medium">Branch {hoveredNode.branchId}</span>
            </div>
            <div className="text-sm text-gray-600">
              {hoveredNode.messages.length} messages in this branch
              {hoveredNode.children.length > 0 && (
                <span className="ml-2">
                  • {hoveredNode.children.length} sub-branches
                </span>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default ConversationFlowVis;


// ========================================
// File: simplified-ui/src/components/ExploreTab.jsx
// ========================================

import {
    motion,
    AnimatePresence,
} from "framer-motion";
import React, {
    useState,
    useRef,
    useContext,
} from "react";
import {
    Loader2,
    Mic,
    MicOff,
    Search,
    ArrowRight,
    AlertTriangle,
    Brain,
} from "lucide-react";
import {
    Card,
    CardContent,
    Button,
    ScrollArea,
    Badge,
} from "./index";
import { Alert, AlertDescription } from "./ui/alert";
import ChatUI from "./ChatUI";
import AudioVisualizer from "./AudioVisualizer";

import { cn } from "./lib/utils";



const ExploreTab = () => {
    const [isListening, setIsListening] = useState(false);
    const [transcript, setTranscript] = useState("");
    const [processing, setProcessing] = useState(false);
    const [suggestions, setSuggestions] = useState([]);
    const [relatedChats, setRelatedChats] = useState([]);
    const [error, setError] = useState(null);
    const audioContextRef = useRef(null);
    const streamRef = useRef(null);
    const mediaRecorderRef = useRef(null);
    const audioChunksRef = useRef([]);
    const [isChatting, setIsChatting] = useState(false);
    const [selectedTopic, setSelectedTopic] = useState("");
    const [selectedModel, setSelectedModel] = useState(null);

    const startListening = async () => {
        try {
            setError(null);
            audioChunksRef.current = [];
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            streamRef.current = stream;
            audioContextRef.current = new (window.AudioContext ||
                window.webkitAudioContext)();
            mediaRecorderRef.current = new MediaRecorder(stream);

            mediaRecorderRef.current.addEventListener("dataavailable", (event) => {
                audioChunksRef.current.push(event.data);
            });

            mediaRecorderRef.current.addEventListener("stop", async () => {
                const audioBlob = new Blob(audioChunksRef.current, {
                    type: "audio/webm",
                });
                await sendToWhisperServer(audioBlob);
                stream.getTracks().forEach((track) => track.stop());
                streamRef.current = null;
            });

            mediaRecorderRef.current.start(1000);
            setIsListening(true);
        } catch (error) {
            setError("Could not access microphone. Please check permissions.");
            console.error("Error starting recording:", error);
        }
    };

    const stopListening = () => {
        if (mediaRecorderRef.current?.state === "recording") {
            mediaRecorderRef.current.stop();
            setIsListening(false);
            setProcessing(true);
        }
    };

    const sendToWhisperServer = async (audioBlob) => {
        const url = `http://127.0.0.1:8080/inference`;
        try {
            // Decode the WebM audio data
            const arrayBuffer = await audioBlob.arrayBuffer();
            const audioBuffer = await audioContextRef.current.decodeAudioData(
                arrayBuffer
            );

            // Resample and encode the audio data as WAV at 16 kHz
            const wavBlob = await audioBufferToWav(audioBuffer, 16000);

            // Prepare the form data
            const formData = new FormData();
            formData.append("file", wavBlob, "recording.wav");
            formData.append("temperature", "0.0");

            // Send the WAV file to the server
            const response = await fetch(url, {
                method: "POST",
                body: formData,
            });

            const data = await response.json();
            if (data.text?.trim()) {
                setTranscript(data.text);
                await processTranscript(data.text);
            }
        } catch (error) {
            setError("Failed to process audio. Please try again.");
            console.error("Transcription error:", error);
        } finally {
            setProcessing(false);
        }
    };

    async function audioBufferToWav(buffer, sampleRate = 16000) {
        // Create an OfflineAudioContext with the desired sample rate
        const offlineContext = new OfflineAudioContext(
            buffer.numberOfChannels,
            buffer.duration * sampleRate,
            sampleRate
        );

        // Create a buffer source for the original audio
        const source = offlineContext.createBufferSource();
        source.buffer = buffer;

        // Connect the source to the destination
        source.connect(offlineContext.destination);

        // Start the source
        source.start(0);

        // Render the audio
        const resampledBuffer = await offlineContext.startRendering();

        // Convert the resampled buffer to WAV
        return bufferToWave(resampledBuffer, resampledBuffer.length);
    }

    function bufferToWave(abuffer, len) {
        let numOfChan = abuffer.numberOfChannels,
            length = len * numOfChan * 2 + 44,
            buffer = new ArrayBuffer(length),
            view = new DataView(buffer),
            channels = [],
            i,
            sample,
            offset = 0,
            pos = 0;

        // Write WAV header
        setUint32(0x46464952); // "RIFF"
        setUint32(length - 8); // file length - 8
        setUint32(0x45564157); // "WAVE"
        setUint32(0x20746d66); // "fmt " chunk
        setUint32(16); // length = 16
        setUint16(1); // PCM (uncompressed)
        setUint16(numOfChan);
        setUint32(abuffer.sampleRate);
        setUint32(abuffer.sampleRate * numOfChan * 2); // avg. bytes/sec
        setUint16(numOfChan * 2); // block-align
        setUint16(16); // 16-bit (hardcoded)

        setUint32(0x61746164); // "data" - chunk
        setUint32(length - pos - 4); // chunk length

        // Write interleaved data
        for (i = 0; i < numOfChan; i++) {
            channels.push(abuffer.getChannelData(i));
        }

        while (pos < length) {
            for (i = 0; i < numOfChan; i++) {
                sample = Math.max(-1, Math.min(1, channels[i][offset])); // Clamp
                sample = sample < 0 ? sample * 0x8000 : sample * 0x7fff; // Convert to 16-bit PCM
                view.setInt16(pos, sample, true); // Write 16-bit sample
                pos += 2;
            }
            offset++; // Next source sample
        }

        // Create Blob
        return new Blob([buffer], { type: "audio/wav" });

        function setUint16(data) {
            view.setUint16(pos, data, true);
            pos += 2;
        }

        function setUint32(data) {
            view.setUint32(pos, data, true);
            pos += 4;
        }
    }

    const handleSuggestionClick = async (suggestion) => {
        setSelectedTopic(suggestion.description);
        setIsChatting(true);
    };

    const url_reflect = `http://127.0.0.1:5001/api/get-reflection`;
    const url_chat = `http://localhost:11434/api/chat`;

    const processTranscript = async (text) => {
        try {
            const [reflectionsResponse, suggestResponse] = await Promise.all([
                fetch(url_reflect, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ context: text }),
                }),
                fetch(url_chat, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        model: "qwen2.5-coder:7b",
                        messages: [
                            {
                                role: "user",
                                content: `Give 3 relevant exploration directions based on: "${text}". Return ONLY a JSON array of clear, actionable suggestions.`,
                            },
                        ],
                        stream: false,
                    }),
                }),
            ]);

            const [reflectionsData, suggestData] = await Promise.all([
                reflectionsResponse.json(),
                suggestResponse.json(),
            ]);


            setRelatedChats(reflectionsData.reflections || []);

            if (suggestData.message?.content) {
                try {
                    const cleanContent = suggestData.message.content
                        .replace(/```json\s*|\s*```/g, "")
                        .trim();
                    const suggestions = JSON.parse(cleanContent);
                    setSuggestions(Array.isArray(suggestions) ? suggestions : []);
                } catch (e) {
                    console.error("Error parsing suggestions:", e);
                    setSuggestions([]);
                }
            }
        } catch (error) {
            setError("Failed to process input. Please try again.");
            console.error("Error processing transcript:", error);
            setSuggestions([]);
            setRelatedChats([]);
        }
    };

    return (
        <div className="relative h-full flex flex-col items-center justify-center p-8">
            {!isChatting ? (
                <div className="max-w h-full w-full space-y-20">
                    {/* Audio Visualization */}
                    <AnimatePresence>
                        {isListening && (
                            <motion.div
                                initial={{ opacity: 0, y: 20 }}
                                animate={{ opacity: 1, y: 0 }}
                                exit={{ opacity: 0, y: -20 }}
                                className="w-full h-full"
                            >
                                <AudioVisualizer
                                    isRecording={isListening}
                                    audioContext={audioContextRef.current}
                                    stream={streamRef.current}
                                />
                            </motion.div>
                        )}
                    </AnimatePresence>

                    {/* Main Content */}
                    <motion.div
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        className="space-y-20 text-center"
                    >
                        {!transcript && !processing && (
                            <motion.h2
                                className="text-xl font-bold tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-primary to-primary/60"
                                initial={{ opacity: 0 }}
                                animate={{ opacity: 1 }}
                                transition={{ delay: 0.2 }}
                            >
                                What would you like to explore today?
                            </motion.h2>
                        )}

                        {/* Error Alert */}
                        <AnimatePresence>
                            {error && (
                                <motion.div
                                    initial={{ opacity: 0, y: -20 }}
                                    animate={{ opacity: 1, y: 0 }}
                                    exit={{ opacity: 0, y: -20 }}
                                >
                                    <Alert variant="destructive">
                                        <AlertTriangle className="h-4 w-4" />
                                        <AlertDescription>{error}</AlertDescription>
                                    </Alert>
                                </motion.div>
                            )}
                        </AnimatePresence>

                        {/* Microphone Button */}
                        <div className="flex justify-center">
                            <Button
                                size="lg"
                                className={cn(
                                    "gap-2 transition-all duration-300",
                                    isListening && "bg-red-500 hover:bg-red-600"
                                )}
                                onClick={isListening ? stopListening : startListening}
                            >
                                {isListening ? (
                                    <>
                                        <MicOff className="h-5 w-5" />
                                        Stop Recording
                                    </>
                                ) : (
                                    <>
                                        <Mic className="h-5 w-5" />
                                        Start Speaking
                                    </>
                                )}
                            </Button>
                        </div>

                        {/* Processing State */}
                        <AnimatePresence>
                            {processing && (
                                <motion.div
                                    initial={{ opacity: 0, scale: 0.95 }}
                                    animate={{ opacity: 1, scale: 1 }}
                                    exit={{ opacity: 0, scale: 0.95 }}
                                    className="flex flex-col items-center gap-4"
                                >
                                    <Loader2 className="h-8 w-8 animate-spin text-primary" />
                                    <p className="text-lg text-muted-foreground">
                                        Processing your request...
                                    </p>
                                </motion.div>
                            )}
                        </AnimatePresence>

                        {/* Results */}
                        <AnimatePresence>
                            {transcript && !processing && (
                                <motion.div
                                    initial={{ opacity: 0, y: 20 }}
                                    animate={{ opacity: 1, y: 0 }}
                                    exit={{ opacity: 0, y: -20 }}
                                    className="space-y-8"
                                >
                                    {/* Transcript */}
                                    <Card>
                                        <CardContent className="p-6">
                                            <p className="text-lg">{transcript}</p>
                                        </CardContent>
                                    </Card>

                                    {/* Suggestions */}
                                    {suggestions.length > 0 && (
                                        <motion.div
                                            className="space-y-4"
                                            initial={{ opacity: 0 }}
                                            animate={{ opacity: 1 }}
                                            transition={{ delay: 0.2 }}
                                        >
                                            <h3 className="text-xl font-semibold">
                                                Suggested Directions
                                            </h3>
                                            <div className="grid gap-4">
                                                {suggestions.map((suggestion, index) => (
                                                    <motion.div
                                                        key={index}
                                                        initial={{ opacity: 0, x: -20 }}
                                                        animate={{ opacity: 1, x: 0 }}
                                                        transition={{ delay: index * 0.1 }}
                                                    >
                                                        <Button
                                                            variant="outline"
                                                            className="w-full flex items-center justify-between p-6 h-auto hover:shadow-lg hover:scale-[1.02] transition-all duration-300"
                                                            onClick={() => handleSuggestionClick(suggestion)}
                                                        >
                                                            <div className="flex items-center gap-4">
                                                                <Brain className="h-5 w-5 text-primary" />
                                                                <span className="text-left">
                                                                    {suggestion.description}
                                                                </span>{" "}
                                                                {/* Updated */}
                                                            </div>
                                                            <ArrowRight className="h-4 w-4" />
                                                        </Button>
                                                    </motion.div>
                                                ))}
                                            </div>
                                        </motion.div>
                                    )}

                                    {/* Related Chats */}
                                    {relatedChats.length > 0 && (
                                        <motion.div
                                            className="space-y-4"
                                            initial={{ opacity: 0 }}
                                            animate={{ opacity: 1 }}
                                            transition={{ delay: 0.4 }}
                                        >
                                            <h3 className="text-xl font-semibold">
                                                Related Past Conversations
                                            </h3>
                                            <ScrollArea className="h-[300px]">
                                                <div className="grid gap-4 pr-4">
                                                    {relatedChats.map((chat, index) => (
                                                        <motion.div
                                                            key={index}
                                                            initial={{ opacity: 0, y: 20 }}
                                                            animate={{ opacity: 1, y: 0 }}
                                                            transition={{ delay: index * 0.1 }}
                                                        >
                                                            <Card className="hover:shadow-lg transition-all duration-300">
                                                                <CardContent className="p-6">
                                                                    <div className="flex items-start gap-4">
                                                                        <Search className="h-5 w-5 mt-1 text-primary" />
                                                                        <div className="flex-1">
                                                                            <Badge
                                                                                variant="secondary"
                                                                                className="mb-2"
                                                                            >
                                                                                Previous Discussion
                                                                            </Badge>
                                                                            <p className="text-sm leading-relaxed">
                                                                                {chat}
                                                                            </p>
                                                                        </div>
                                                                    </div>
                                                                </CardContent>
                                                            </Card>
                                                        </motion.div>
                                                    ))}
                                                </div>
                                            </ScrollArea>
                                        </motion.div>
                                    )}
                                </motion.div>
                            )}
                        </AnimatePresence>
                    </motion.div>
                </div>
            ) : (
                <ChatUI
                    topic={selectedTopic}
                    model={selectedModel}
                    onBack={() => setIsChatting(false)}
                />
            )}
        </div>
    );
};


export default ExploreTab;


// ========================================
// File: simplified-ui/src/components/FileUploader.jsx
// ========================================

import React, {
    useEffect,
    useState,
    useRef,
    useContext,
} from "react";
import {
    Loader2,
    AlertTriangle,
    Upload,
    CheckCircle2,
    File,
} from "lucide-react";
import {
    Button,
    DialogFooter,
    Dialog,
    DialogContent,
    DialogDescription,
    DialogHeader,
    DialogTitle,
    Progress,
} from "./index";
import { Alert, AlertDescription } from "./ui/alert";


export default function FileUploader({ onProcessingComplete }) {
    const [isOpen, setIsOpen] = useState(false);
    const [taskId, setTaskId] = useState(null);
    const [status, setStatus] = useState(null);
    const [error, setError] = useState(null);
    const fileInputRef = useRef(null);
    const pollInterval = useRef(null);

    const resetState = () => {
        setTaskId(null);
        setStatus(null);
        setError(null);
        if (pollInterval.current) {
            clearInterval(pollInterval.current);
            pollInterval.current = null;
        }
    };

    useEffect(() => {
        return () => {
            if (pollInterval.current) {
                clearInterval(pollInterval.current);
            }
        };
    }, []);

    const startPolling = (taskId) => {
        if (pollInterval.current) {
            clearInterval(pollInterval.current);
        }

        const url = `http://127.0.0.1:5001/api/process/status/${taskId}`;

        const poll = async () => {
            try {
                const response = await fetch(url);

                const data = await response.json();

                if (data.error) {
                    setError(data.error);
                    clearInterval(pollInterval.current);
                    return;
                }

                setStatus(data);

                if (data.completed || data.status === "failed") {
                    clearInterval(pollInterval.current);
                    if (data.completed) {
                        // Wait a short moment before refreshing to ensure all files are written
                        setTimeout(() => {
                            if (onProcessingComplete) {
                                onProcessingComplete();
                            }
                        }, 1000);
                    }
                }
            } catch (error) {
                console.error("Error polling status:", error);
                setError("Failed to check processing status");
                clearInterval(pollInterval.current);
            }
        };

        poll(); // Initial poll
        pollInterval.current = setInterval(poll, 1000);
    };

    const handleFileUpload = async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        setIsOpen(true);
        resetState();
        setError(null);

        const formData = new FormData();
        formData.append("file", file);

        const url = `http://127.0.0.1:5001/api/process`;
        try {
            const response = await fetch(url, {
                method: "POST",
                body: formData,
            });


            const data = await response.json();

            if (data.error) {
                setError(data.error);
                return;
            }

            setTaskId(data.task_id);
            startPolling(data.task_id);
        } catch (err) {
            setError(err.message);
        }
    };

    const getStatusDisplay = () => {
        if (!status) return null;

        const steps = [
            {
                key: "uploading",
                title: "Uploading Data",
                description: "Uploading your conversations file...",
            },
            {
                key: "analyzing_chats",
                title: "Analyzing Conversations",
                description: "Processing chat data and identifying patterns...",
            },
            {
                key: "processing",
                title: "Processing Data",
                description: "Generating topics and analyzing relationships...",
            },
        ];

        return steps.map((step, index) => (
            <div
                key={step.key}
                className={`flex items-center gap-3 ${status.status === step.key
                    ? "text-primary"
                    : index < steps.findIndex((s) => s.key === status.status)
                        ? "text-muted-foreground line-through"
                        : "text-muted-foreground"
                    }`}
            >
                {status.status === step.key ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                ) : index < steps.findIndex((s) => s.key === status.status) ? (
                    <CheckCircle2 className="h-4 w-4" />
                ) : (
                    <File className="h-4 w-4" />
                )}
                <div className="flex-1">
                    <div className="text-sm font-medium">{step.title}</div>
                    <div className="text-xs">{step.description}</div>
                </div>
            </div>
        ));
    };

    return (
        <>
            <div className="flex items-center">
                <input
                    ref={fileInputRef}
                    type="file"
                    accept=".json"
                    onChange={handleFileUpload}
                    className="hidden"
                    id="conversation-upload"
                />
                <Button
                    variant="outline"
                    size="icon"
                    onClick={() => fileInputRef.current?.click()}
                >
                    <Upload className="h-4 w-4" />
                </Button>
            </div>
            <Dialog open={isOpen} onOpenChange={setIsOpen}>
                <DialogContent className="sm:max-w-[425px]">
                    <DialogHeader>
                        <DialogTitle>Processing Data</DialogTitle>
                        <DialogDescription>
                            Analyzing your conversation data to generate insights
                        </DialogDescription>
                    </DialogHeader>

                    <div className="space-y-6 py-4">
                        {error ? (
                            <Alert variant="destructive">
                                <AlertTriangle className="h-4 w-4" />
                                <AlertDescription>{error}</AlertDescription>
                            </Alert>
                        ) : (
                            <>
                                <Progress value={status?.progress || 0} className="w-full" />
                                <div className="space-y-4">{getStatusDisplay()}</div>
                            </>
                        )}
                    </div>

                    <DialogFooter>
                        {(status?.completed || error) && (
                            <Button
                                onClick={() => {
                                    setIsOpen(false);
                                    resetState();
                                }}
                            >
                                Close
                            </Button>
                        )}
                    </DialogFooter>
                </DialogContent>
            </Dialog>
        </>
    );
}


// ========================================
// File: simplified-ui/src/components/FloatingInput.jsx
// ========================================

import { useState, useEffect, useRef } from 'react';
import { X, Send, Loader2, Mic } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { RecordingButton } from './RecordingButton';

const FloatingInput = ({ 
  onSend, 
  isLoading, 
  show, 
  onClose, 
  position, 
  inputValue, 
  onInputChange 
}) => {
  const inputRef = useRef(null);
  const [isTranscribing, setIsTranscribing] = useState(false);

  const handleSendMessage = () => {
    if (inputValue.trim() && !isLoading && !isTranscribing) {
      onSend();
      onClose();
    }
  };

  const handleTranscriptionComplete = (transcript) => {
    onInputChange(transcript);
    setIsTranscribing(false);
    if (transcript.trim()) {
      handleSendMessage();
    }
  };

  const handleTranscriptionStart = () => {
    setIsTranscribing(true);
    onInputChange('');
  };

  useEffect(() => {
    if (show && inputRef.current) {
      inputRef.current.focus();
    }
  }, [show]);

  return (
    <AnimatePresence>
      {show && (
        <motion.div 
          initial={{ y: 100, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          exit={{ y: 100, opacity: 0 }}
          transition={{ type: "spring", stiffness: 300, damping: 50 }}
          className="fixed z-50 bg-background/95 backdrop-blur-sm border border-border rounded-lg shadow-lg p-4 w-96"
          style={{
            left: `${position?.x ?? window.innerWidth / 2 - 192}px`,
            top: `${position?.y ?? window.innerHeight - 90}px`
          }}
        >    
          <div className="flex gap-2">
            <textarea
              ref={inputRef}
              value={inputValue}
              onChange={onInputChange}
              onKeyDown={(e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                  e.preventDefault();
                  handleSendMessage();
                } else if (e.key === 'Escape') {
                  onClose();
                }
              }}
              placeholder="Type your message..."
              rows={1}
              className="flex-1 px-3 py-2 rounded-lg bg-muted/50 border border-border resize-none focus:outline-none focus:ring-2 focus:ring-ring"
              disabled={isTranscribing}
            />

            <RecordingButton
              onTranscriptionComplete={handleTranscriptionComplete}
              onTranscriptionStart={handleTranscriptionStart}
              onRecordingStop={() => setIsTranscribing(false)}
              disabled={isLoading}
            />
            
            <button
              onClick={handleSendMessage}
              disabled={!inputValue.trim() || isLoading || isTranscribing}
              className="px-3 py-2 rounded-lg bg-primary text-primary-foreground hover:bg-primary/90 disabled:opacity-50 transition-colors"
            >
              {isLoading ? (
                <Loader2 className="w-4 h-4 animate-spin" />
              ) : (
                <Send className="w-4 h-4" />
              )}
            </button>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default FloatingInput;


// ========================================
// File: simplified-ui/src/components/HoverTooltip.jsx
// ========================================


// HoverTooltip.jsx
import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';

const HoverTooltip = ({ hoveredPoint }) => {
  if (!hoveredPoint) return null;

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0, y: 5 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: 5 }}
        transition={{ duration: 0.2 }}
        className="fixed pointer-events-none z-50 bg-popover/95 backdrop-blur-sm border rounded-lg shadow-lg p-4"
        style={{
          left: hoveredPoint.x + 15,
          top: hoveredPoint.y - 15,
          transform: "translate(-50%, -100%)",
          maxWidth: "320px",
        }}
      >
        <div className="space-y-1">
          <div className="font-medium">{hoveredPoint.title}</div>
          <div className="text-sm text-muted-foreground">{hoveredPoint.topic}</div>
          {hoveredPoint.branchCount && (
            <div className="text-sm font-medium text-primary">
              {hoveredPoint.branchCount}
            </div>
          )}
          {hoveredPoint.hasReflection && (
            <div className="text-xs text-yellow-500">Has reflection</div>
          )}
          {hoveredPoint.coherence && (
            <div className="text-xs text-muted-foreground">
              Coherence: {Math.round(hoveredPoint.coherence * 100)}%
            </div>
          )}
        </div>
      </motion.div>
    </AnimatePresence>
  );
};

export default HoverTooltip;





// ========================================
// File: simplified-ui/src/components/IntegratedDashboard.jsx
// ========================================

import React, { useState, useCallback, useEffect } from 'react';
import axios from "axios";
import { motion, AnimatePresence, LayoutGroup } from 'framer-motion';
import { Tabs, TabsList, TabsTrigger, TabsContent } from './ui/tabs';
import { Share2, Download, ArrowLeft, Plus, Bot, PanelLeftClose, PanelLeft } from 'lucide-react';
import ChatPersistenceManager from './ChatPersistanceManager';
import FileUploader from './FileUploader';
import { Button } from './ui/button';
import ModelsModal from './ModelsModal';
import { ThemeToggle } from './ThemeToggle';
import { ScrollArea } from './ui/scroll-area';
import TangentLogo from './TangentLogo';
import { Sparkles, ChartBarIcon, Text } from 'lucide-react';
import ExploreTab from './ExploreTab';
import TopicsPanel from './TopicsPanel';
import MainDashboard from './MainDashboard';
import TangentChat from './TangentChat';
import { useVisualization } from './VisualizationProvider';


const SharedHeader = ({
  handleRefresh,
  theme,
  setTheme,
  onNewThread,
  onManageModels,
  isPanelCollapsed,
  onPanelToggle,
  nodes,
  setNodes,
  activeChat,
  setActiveChat
}) => {
  return (
    <header className={`${isPanelCollapsed ? 'w-screen' : 'w-[80vw]'} h-16 bg-background border border-border ${isPanelCollapsed ? 'left-0' : 'left-[20vw]'} z-[100] flex items-center px-6 transition-all duration-300`}>
      <Button
        variant="outline"
        size="icon"
        onClick={onPanelToggle}
        className="h-9 w-9 bg-background border-border"
      >
        {isPanelCollapsed ? (
          <PanelLeft className="h-4 w-4" />
        ) : (
          <PanelLeftClose className="h-4 w-4" />
        )}
      </Button>

      <div className="absolute left-0 w-full flex justify-center pointer-events-none">
        <TangentLogo className="h-6 w-auto" />
      </div>

      <div className="flex items-center gap-2 ml-auto">
        <Button
          variant="outline"
          size="icon"
          className="h-9 w-9 bg-background border-border"
        >
          <ThemeToggle theme={theme} setTheme={setTheme} />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={onManageModels}
          className="h-9 w-9 bg-background border-border"
        >
          <Bot className="h-4 w-4" />
        </Button>
        <FileUploader
          onProcessingComplete={handleRefresh}
          buttonProps={{
            variant: "outline",
            size: "icon",
            className: "h-9 w-9 bg-background border-border"
          }}
        />
        <Button
          variant="outline"
          size="icon"
          className="h-9 w-9 bg-background border-border"
        >
          <Share2 className="h-4 w-4" />
        </Button>
        <Button
          onClick={onNewThread}
          variant="default"
          size="icon"
          className="h-9 w-9 bg-primary"
        >
          <Plus className="h-4 w-4" />
        </Button>

        <ChatPersistenceManager
          nodes={nodes}
          onLoadChat={setNodes}
          activeChat={activeChat}
          setActiveChat={setActiveChat}
        />
      </div>
    </header>
  );
};

export const SharedHeaderWrapper = ({ onNewThread, onManageModels }) => {
  const { handleRefresh, theme, setTheme, view, setView } = useVisualization();
  const [lastConversation, setLastConversation] = useState(null);

  const handleBack = useCallback((conversation = null) => {
    if (conversation) {
      setView('conversation');
      setLastConversation(conversation);
    } else {
      setView('clusters');
    }
  }, [setView]);

  return (
    <SharedHeader
      handleRefresh={handleRefresh}
      theme={theme}
      setTheme={setTheme}
      currentView={view}
      handleBack={handleBack}
      onNewThread={onNewThread}
      lastConversation={lastConversation}
      onManageModels={onManageModels}
    />
  );
};


export const IntegratedDashboard = () => {
  const [selectedNodePosition, setSelectedNodePosition] = useState(null);
  const [selectedConversation, setSelectedConversation] = useState(null);
  const [view, setView] = useState('clusters');
  const [lastThread, setLastThread] = useState(null);
  const { handleRefresh, theme, setTheme } = useVisualization();
  const [activeTab, setActiveTab] = React.useState('dashboard');
  const [isPanelCollapsed, setIsPanelCollapsed] = useState(true);
  const [showQuickInput, setShowQuickInput] = useState(true);
  // Models state management
  const [showModelsModal, setShowModelsModal] = useState(false);
  const [selectedModel, setSelectedModel] = useState('');
  const [localModels, setLocalModels] = useState([]);
  const [runningModels, setRunningModels] = useState([]);
  const [modelInfo, setModelInfo] = useState(null);
  const [pullModelName, setPullModelName] = useState("");
  const [isPulling, setIsPulling] = useState(false);
  const [pullStatus, setPullStatus] = useState("");
  const [detailedView, setDetailedView] = useState(false);

  const [nodes, setNodes] = useState([{
    id: 1,
    messages: [],
    x: window.innerWidth / 2 - 200,
    y: 100,
    type: 'main',
    title: 'Main Thread',
    branchId: '0'
  }]);

  const [activeChat, setActiveChat] = useState(null);

  // Add these state declarations at the top with other states
  const [sortBy, setSortBy] = useState('relevance');
  const [selectedCluster, setSelectedCluster] = useState(null);
  const [data, setData] = useState(null);

  // Add this function with other handlers
  const handleTopicSelect = (clusterId) => {
    setSelectedCluster(parseInt(clusterId));
  };

  // Add this function to match what's used in MainDashboard
  function getColor(index) {
    const colors = [
      "#60A5FA", "#F87171", "#34D399", "#FBBF24", "#A78BFA",
      "#F472B6", "#FB923C", "#2DD4BF", "#4ADE80", "#A3E635",
      "#38BDF8", "#FB7185", "#818CF8", "#C084FC", "#E879F9",
      "#22D3EE", "#F43F5E", "#10B981", "#6366F1", "#8B5CF6"
    ];
    return colors[index % colors.length];
  }

  const handleModelClick = async (modelName) => {
    try {
      const response = await fetch("http://localhost:11434/api/show", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ model: modelName }),
      });
      const data = await response.json();
      setSelectedModel(modelName);
      setModelInfo(data);
    } catch (error) {
      console.error("Error fetching model info:", error);
    }
  };

  const handleDeleteModel = async (modelName) => {
    if (!window.confirm(`Are you sure you want to delete model "${modelName}"?`)) return;
    try {
      await fetch("http://localhost:11434/api/delete", {
        method: "DELETE",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ model: modelName }),
      });
      const response = await fetch('http://localhost:11434/api/tags');
      const data = await response.json();
      setLocalModels(data.models);
    } catch (error) {
      console.error("Error deleting model:", error);
    }
  };

  const handlePullModel = async () => {
    if (!pullModelName.trim()) {
      alert("Please enter a model name");
      return;
    }
    setIsPulling(true);
    setPullStatus("Starting download...");
    try {
      const response = await fetch("http://localhost:11434/api/pull", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ model: pullModelName.trim(), stream: false }),
      });
      if (!response.ok) throw new Error("Failed to pull model");
      setPullStatus("Model downloaded successfully");
      setPullModelName("");
      const tagsResponse = await fetch('http://localhost:11434/api/tags');
      const data = await tagsResponse.json();
      setLocalModels(data.models);
    } catch (error) {
      console.error("Error pulling model:", error);
      setPullStatus(`Error: ${error.message}`);
    } finally {
      setIsPulling(false);
    }
  };

  const handleManageModels = useCallback(() => {
    setShowModelsModal(true);
  }, []);

  const handleSave = useCallback(async () => {
    if (!nodes.length) return;
  
    try {
      const chatData = {
        chatId: activeChat?.id || undefined,
        nodes,
        title: activeChat?.title || 'Untitled Chat',
        metadata: {
          nodeCount: nodes.length,
          messageCount: nodes.reduce((acc, node) => acc + node.messages.length, 0)
        }
      };
  
      const response = await axios.post('http://localhost:5001/api/chats/save', chatData);
      if (response.data.success) {
        setActiveChat({
          id: response.data.chatId,
          title: chatData.title
        });
      }
    } catch (error) {
      console.error('Error saving chat:', error);
    }
  }, [nodes, activeChat]);

  
  const handleNewThread = useCallback(() => {
    const newConversation = [{
      id: Date.now(),
      messages: [],
      type: 'main',
      title: 'Main Thread',
      x: window.innerWidth / 4,
      y: window.innerHeight / 3,
      branchId: '0'
    }, {
      id: Date.now() + 1,
      messages: [],
      type: 'branch',
      title: 'New Thread',
      x: window.innerWidth / 2,
      y: window.innerHeight / 2,
      parentId: Date.now(),
      systemPrompt: '',
      parentMessageIndex: 0,
      branchId: '0.0'
    }];
    setSelectedConversation(newConversation);
    setLastThread(newConversation);
    setSelectedNodePosition({
      x: window.innerWidth / 2,
      y: window.innerHeight / 2
    });
    setView('conversation');
  }, []);

  useEffect(() => {
    const handleOpenConversation = (event) => {
      const { nodes, position } = event.detail;
      setSelectedConversation(nodes);
      setLastThread(nodes);
      setSelectedNodePosition(position);
      setView('conversation');
    };

    window.addEventListener('openConversation', handleOpenConversation);

    return () => {
      window.removeEventListener('openConversation', handleOpenConversation);
    };
  }, []);

  useEffect(() => {
    const handleKeyDown = (e) => {
      const isTyping = document.activeElement.tagName === 'INPUT' ||
        document.activeElement.tagName === 'TEXTAREA';
  
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's' && !isTyping) {
        e.preventDefault();
        handleSave();
      }
    };
  
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleSave]);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch("http://127.0.0.1:5001/api/visualization");
        const responseData = await response.json();
        const chatsWithReflections = new Set(responseData.chats_with_reflections);

        const chartData = [{
          id: 'points',
          data: responseData.points.map((point, i) => ({
            x: point[0],
            y: point[1],
            cluster: responseData.clusters[i],
            title: responseData.titles[i],
            hasReflection: chatsWithReflections.has(responseData.titles[i])
          }))
        }];

        setData({
          chartData,
          topics: responseData.topics
        });
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };

    fetchData();
  }, []);

  const handleTopicConversationSelect = async (chat) => {
    try {
      const baseTitle = chat.title.replace(/ \(Branch \d+\)$/, '');

      // Get the branched data
      const response = await fetch(
        `http://127.0.0.1:5001/api/messages_all/${encodeURIComponent(baseTitle)}?type=claude`
      );
      const messageData = await response.json();

      if (!messageData || !messageData.branches) {
        console.error('Failed to fetch conversation data');
        return;
      }

      // Build nodes structure for TangentChat
      const nodes = buildConversationNodes(messageData, baseTitle);
      console.log("Processed nodes:", nodes);

      if (!nodes || nodes.length === 0) {
        console.error('No valid nodes created from message data');
        return;
      }

      // Calculate center position for positioning the nodes
      const clickPosition = {
        x: window.innerWidth / 2,
        y: window.innerHeight / 2
      };

      // Update the conversation state and view
      setSelectedConversation(nodes);
      setLastThread(nodes);
      setSelectedNodePosition(clickPosition);
      setView('conversation');
    } catch (error) {
      console.error('Error in conversation click handler:', error);
    }
  };

  // Helper function to build conversation nodes
  const buildConversationNodes = (responseData, chatTitle) => {
    if (!responseData || !responseData.branches) {
      console.error('Invalid response data structure');
      return [];
    }

    const nodes = [];
    const messageToNodeMap = new Map();
    let nodeIdCounter = 1;

    // First create the main thread (branch '0')
    const mainBranch = responseData.branches['0'];
    if (mainBranch) {
      const mainNode = {
        id: nodeIdCounter++,
        title: chatTitle,
        messages: mainBranch.map(msg => ({
          role: msg.sender === 'human' ? 'user' : 'assistant',
          content: msg.text,
          messageId: msg.message_id
        })),
        type: 'main',
        branchId: '0',
        x: window.innerWidth / 4,
        y: window.innerHeight / 3
      };
      nodes.push(mainNode);
      mainBranch.forEach(msg => messageToNodeMap.set(msg.message_id, mainNode.id));
    }

    // Then create all branch nodes
    Object.entries(responseData.branches).forEach(([branchId, messages]) => {
      if (branchId === '0') return; // Skip main thread

      const firstMessage = messages[0];
      if (!firstMessage?.parent_message_id) return;

      const parentNodeId = messageToNodeMap.get(firstMessage.parent_message_id);
      const parentNode = nodes.find(n => n.id === parentNodeId);

      if (!parentNode) {
        console.warn(`Parent node not found for branch ${branchId}`);
        return;
      }

      const parentMessageIndex = parentNode.messages.findIndex(
        msg => msg.messageId === firstMessage.parent_message_id
      );

      const branchNode = {
        id: nodeIdCounter++,
        title: `${chatTitle} (Branch ${branchId})`,
        messages: messages.map(msg => ({
          role: msg.sender === 'human' ? 'user' : 'assistant',
          content: msg.text,
          messageId: msg.message_id
        })),
        type: 'branch',
        parentId: parentNodeId,
        parentMessageIndex: parentMessageIndex >= 0 ? parentMessageIndex : 0,
        branchId: branchId,
        x: parentNode.x + 300,
        y: parentNode.y + (parentMessageIndex * 50),
        // Add context messages for the branch
        contextMessages: [
          ...parentNode.messages.slice(0, parentMessageIndex + 1),
          ...messages.map(msg => ({
            role: msg.sender === 'human' ? 'user' : 'assistant',
            content: msg.text,
            messageId: msg.message_id
          }))
        ]
      };

      nodes.push(branchNode);
      messages.forEach(msg => messageToNodeMap.set(msg.message_id, branchNode.id));
    });

    return nodes;
  };

  return (
    <div className="flex h-screen w-full bg-background overflow-hidden">
      {/* Left Sidebar */}
      {!isPanelCollapsed && (
        <div className="fixed top-0 left-0 w-[20vw] h-full py-2 border-r border-border flex flex-col transition-all duration-300">
          <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1 flex flex-col">
            <div className="px-4 py-2">
              <TabsList className="grid w-full grid-cols-3">
                <TabsTrigger value="dashboard" className="gap-2">
                  <Sparkles className="h-4 w-4" />
                  Map
                </TabsTrigger>
                <TabsTrigger value="explore" className="gap-2">
                  <ChartBarIcon className="h-4 w-4" />
                  Explore
                </TabsTrigger>
                <TabsTrigger value="topics" className="gap-2">
                  <Text className="h-4 w-4" />
                  Topics
                </TabsTrigger>
              </TabsList>
            </div>

            <div className="flex-1 p-4 overflow-hidden">
              <TabsContent value="dashboard" className="h-full m-0 overflow-hidden">
                <MainDashboard />
              </TabsContent>
              <TabsContent value="explore" className="h-full m-0">
                <ScrollArea className="h-full">
                  <ExploreTab />
                </ScrollArea>
              </TabsContent>
              <TabsContent value="topics" className="h-full m-0">
                <ScrollArea className="h-full">
                  <TopicsPanel
                    data={data}
                    sortBy={sortBy}
                    setSortBy={setSortBy}
                    selectedCluster={selectedCluster}
                    handleTopicSelect={handleTopicSelect}
                    getColor={getColor}
                    onConversationSelect={handleTopicConversationSelect}
                  />
                </ScrollArea>
              </TabsContent>
            </div>
          </Tabs>
        </div>
      )}

      {/* Right Content Area */}
      <div className={`${isPanelCollapsed ? 'w-full' : 'ml-[20vw] w-[80vw]'} flex flex-col transition-all duration-300`}>
        <SharedHeader
          handleRefresh={handleRefresh}
          theme={theme}
          setTheme={setTheme}
          currentView={view}
          handleBack={() => setView('clusters')}
          onNewThread={handleNewThread}
          lastConversation={lastThread}
          onManageModels={handleManageModels}
          isPanelCollapsed={isPanelCollapsed}
          onPanelToggle={() => setIsPanelCollapsed(!isPanelCollapsed)}
          nodes={nodes}
          setNodes={setNodes}
          activeChat={activeChat}
          setActiveChat={setActiveChat}
        />

        <ModelsModal
          isOpen={showModelsModal}
          onClose={() => setShowModelsModal(false)}
          models={localModels}
          runningModels={runningModels}
          detailedView={detailedView}
          setDetailedView={setDetailedView}
          onModelClick={handleModelClick}
          onDeleteModel={handleDeleteModel}
          pullModelName={pullModelName}
          setPullModelName={setPullModelName}
          isPulling={isPulling}
          onPullModel={handlePullModel}
          pullStatus={pullStatus}
          modelInfo={modelInfo}
          selectedModel={selectedModel}
        />

        <div className="flex-1 overflow-hidden">
          <TangentChat
            initialConversation={selectedConversation}
            isPanelCollapsed={isPanelCollapsed}
            nodes={nodes}
            setNodes={setNodes}
            activeChat={activeChat}
            setActiveChat={setActiveChat}
          />
        </div>
      </div>
    </div>
  );
};

export default IntegratedDashboard;


// ========================================
// File: simplified-ui/src/components/MainDashboard.jsx
// ========================================

import * as d3 from "d3";
import axios from "axios";
import React, {
    useEffect,
    useState,
    useRef,
    useCallback,
    useContext,
} from "react";
import { Search, ZoomIn, ZoomOut, RefreshCw } from 'lucide-react';

import ReflectionDialog from './ReflectionDialog';
import VisualizationPanel from './VisualizationPanel';
import TopicsPanel from './TopicsPanel';
import HoverTooltip from './HoverTooltip';
import { Card, CardHeader, CardTitle, CardContent } from './ui/card';
import { Input } from './ui/input';
import { debounce } from 'lodash';

// Utility function for getting colors (moved outside component)
function getColor(index) {
    const colors = [
        "#60A5FA",
        "#F87171",
        "#34D399",
        "#FBBF24",
        "#A78BFA",
        "#F472B6",
        "#FB923C",
        "#2DD4BF",
        "#4ADE80",
        "#A3E635",
        "#38BDF8",
        "#FB7185",
        "#818CF8",
        "#C084FC",
        "#E879F9",
        "#22D3EE",
        "#F43F5E",
        "#10B981",
        "#6366F1",
        "#8B5CF6",
    ];
    return colors[index % colors.length];
}

const getThemeColors = (theme) => ({
    text: theme === "dark" ? "#fff" : "#000",
    mutedText: theme === "dark" ? "rgba(255,255,255,0.6)" : "rgba(0,0,0,0.6)",
    link: theme === "dark" ? "rgba(255,255,255,0.3)" : "rgba(0,0,0,0.3)",
    starOutline: theme === "dark" ? "rgba(255,255,255,0.4)" : "rgba(0,0,0,0.4)",
    branchPattern: theme === "dark" ? "#ffffff33" : "#00000033"
});



const MainDashboard = ({ onConversationSelect }) => {  // Add this prop
    const [isTreeView, setIsTreeView] = useState(false);
    const [activeTab, setActiveTab] = useState("map");
    const [selectedChat, setSelectedChat] = useState(null);
    const [data, setData] = useState(null);
    const [selectedCluster, setSelectedCluster] = useState(null);
    const [selectedPoints, setSelectedPoints] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [insights, setInsights] = useState(null);
    const [selectedConversation, setSelectedConversation] = useState(null);
    const [showReflectionDialog, setShowReflectionDialog] = useState(false);
    const [hoveredPoint, setHoveredPoint] = useState(null);
    const [sortBy, setSortBy] = useState("relevance"); // 'relevance', 'size', 'coherence'
    const svgRef = useRef();
    const zoomRef = useRef(null);
    const [isFullscreen, setIsFullscreen] = useState(false);
    const cardRef = useRef(null);
    const nodesDataRef = useRef(null);
    const [innerWidth, setInnerWidth] = useState(0);
    const [isSidebarOpen, setIsSidebarOpen] = useState(false);
    const [currentState, setCurrentState] = useState(null);
    const [, setAvailableStates] = useState([]);
    const [isLoadingState, setIsLoadingState] = useState(false);
    const [chatType, setChatType] = useState('claude');
    const [delayedCluster, setDelayedCluster] = useState(null);
    const [visualizationType, setVisualizationType] = useState('star'); // 'star' or 'islands'
    const [filterText, setFilterText] = useState('');
    const [filteredData, setFilteredData] = useState(null);

    const [theme, setTheme] = useState(() => {
        if (typeof window !== "undefined") {
            return localStorage.getItem("theme") || "light";
        }
        return "light";
    });

    useEffect(() => {
        document.documentElement.classList.remove('light', 'dark', 'hextech-nordic');
        document.documentElement.classList.add(theme);
        localStorage.setItem('theme', theme);
    }, [theme]);


    useEffect(() => {
        const handleResize = () => setInnerWidth(window.innerWidth);
        window.addEventListener("resize", handleResize);
        handleResize();
        return () => window.removeEventListener("resize", handleResize);
    }, []);


    const fetchMessages = async (title, chatType) => {
        const encodedTitle = encodeURIComponent(title);
        try {
            const response = await axios.get(
                `http://127.0.0.1:5001/api/messages/${encodedTitle}?type=${chatType}`,
                {
                    validateStatus: function (status) {
                        return status < 500; // Handle 404s without throwing
                    }
                }
            );
            if (response.status === 200) {
                return response.data;
            }
            return null;
        } catch (error) {
            console.error(`Error fetching with ${chatType}:`, error);
            return null;
        }
    };

    useEffect(() => {
        const fetchData = async () => {
            setIsLoading(true);
            if (svgRef.current) {
                // Clear existing visualization
                const svg = d3.select(svgRef.current);
                svg.selectAll("*").remove();
            }

            try {
                const response = await fetch(`http://127.0.0.1:5001/api/visualization?type=${chatType}`);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const responseData = await response.json();
                const chatsWithReflections = new Set(responseData.chats_with_reflections);

                const chartData = [{
                    id: 'points',
                    data: responseData.points.map((point, i) => ({
                        x: point[0],
                        y: point[1],
                        cluster: responseData.clusters[i],
                        title: responseData.titles[i],
                        hasReflection: chatsWithReflections.has(responseData.titles[i])
                    }))
                }];

                setData({
                    chartData,
                    topics: responseData.topics
                });

            } catch (error) {
                console.error('Error fetching data:', error);
            } finally {
                setIsLoading(false);
            }
        };

        fetchData();
    }, [chatType]);

    const url_visualization = "http://127.0.0.1:5001/api/visualization";

    useEffect(() => {
        const handleEsc = (e) => {
            if (e.key === "Escape") {
                setSelectedCluster(null);
                setShowReflectionDialog(false);
                setIsSidebarOpen(false);
            }
        };

        window.addEventListener("keydown", handleEsc);
        return () => window.removeEventListener("keydown", handleEsc);
    }, []);

    // Debounced filter function
    const debouncedFilter = useRef(
        debounce((searchText) => {
            if (!data) return;

            const filtered = {
                ...data,
                chartData: [{
                    ...data.chartData[0],
                    data: data.chartData[0].data.filter(item =>
                        item.title.toLowerCase().includes(searchText.toLowerCase())
                    )
                }],
                topics: Object.fromEntries(
                    Object.entries(data.topics).filter(([_, topic]) =>
                        topic.topic.toLowerCase().includes(searchText.toLowerCase())
                    )
                )
            };

            setFilteredData(filtered);
        }, 2000)
    ).current;

    // Update filter on text change
    useEffect(() => {
        if (filterText) {
            debouncedFilter(filterText);
        } else {
            setFilteredData(null);
        }
    }, [filterText]);

    // Use filtered or original data for visualization
    const visualizationData = filteredData || data;

    const handleRefresh = async () => {
        setIsLoading(true);
        const url = `http://127.0.0.1:5001/api/visualization?type=${chatType}`;

        try {
            const response = await fetch(url);

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const responseData = await response.json();

            // Validate the response data has the expected structure
            if (
                !responseData.points ||
                !responseData.clusters ||
                !responseData.titles ||
                !responseData.topics
            ) {
                throw new Error("Invalid data structure received from server");
            }

            const chatsWithReflections = new Set(
                responseData.chats_with_reflections || []
            );

            const chartData = [
                {
                    id: "points",
                    data: responseData.points.map((point, i) => ({
                        x: point[0],
                        y: point[1],
                        cluster: responseData.clusters[i],
                        title: responseData.titles[i],
                        hasReflection: chatsWithReflections.has(responseData.titles[i]),
                    })),
                },
            ];

            setData({
                chartData,
                topics: responseData.topics,
            });

            // Only reset visualization state after successful data update
            setSelectedCluster(null);
            setSelectedPoints([]);
            setHoveredPoint(null);

            // Reset zoom after a short delay to ensure data is updated
            setTimeout(() => {
                if (zoomRef.current && svgRef.current) {
                    const width = svgRef.current.clientWidth;
                    const height = svgRef.current.clientHeight;
                    const padding = 40;
                    const visWidth = width - padding;
                    const visHeight = height - padding;
                    const initialScale = 0.08;
                    const initialTransform = d3.zoomIdentity
                        .translate(visWidth / 2, visHeight / 2)
                        .scale(initialScale)
                        .translate(-width / 2, -height / 2);

                    d3.select(svgRef.current)
                        .transition()
                        .duration(750)
                        .call(zoomRef.current.transform, initialTransform);
                }
            }, 100);
        } catch (error) {
            console.error("Error refreshing data:", error);
            // Optionally show an error message to the user
            // You might want to add a toast or alert component for this
        } finally {
            setIsLoading(false);
        }
    };

    const toggleFullscreen = () => {
        if (!cardRef.current) return;

        if (!document.fullscreenElement) {
            cardRef.current.requestFullscreen().catch((err) => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else {
            document.exitFullscreen();
        }
    };

    useEffect(() => {
        const handleFullscreenChange = () => {
            setIsFullscreen(!!document.fullscreenElement);
        };

        document.addEventListener("fullscreenchange", handleFullscreenChange);
        return () =>
            document.removeEventListener("fullscreenchange", handleFullscreenChange);
    }, [])


    useEffect(() => {
        const handleClusterSelection = async () => {
            if (selectedCluster !== null) {
                let nodeData;

                if (visualizationType === 'star') {
                    // For star visualization, find the node in nodesDataRef
                    nodeData = nodesDataRef.current?.find(
                        node => node.size && node.id === selectedCluster
                    );
                } else {
                    // For islands visualization, construct node data from the cluster
                    const clusterData = data.topics[selectedCluster];
                    if (clusterData) {
                        // Find all conversations in this cluster
                        const conversations = data.chartData[0].data.filter(
                            d => d.cluster === selectedCluster
                        );

                        nodeData = {
                            id: selectedCluster,
                            topic: clusterData.topic,
                            width: Math.max(300, conversations.length * 30), // Estimate width based on content
                            height: Math.max(100, conversations.length * 30 + 60), // Estimate height based on content
                        };
                    }
                }

                if (nodeData) {
                    setDelayedCluster(null);
                    await centerOnNode(nodeData);
                    setTimeout(() => {
                        setDelayedCluster(selectedCluster);
                    }, 200);
                }
            } else {
                setDelayedCluster(null);
            }
        };

        handleClusterSelection();
    }, [selectedCluster, visualizationType, data]);

    const handleZoomIn = () => {
        if (!zoomRef.current || !svgRef.current) return;
        const currentScale = d3.zoomTransform(svgRef.current).k;
        const maxScale = visualizationType === 'star' ? 8 : 0.08;

        // Don't zoom in beyond max scale
        if (currentScale * 1.7 <= maxScale) {
            d3.select(svgRef.current)
                .transition()
                .duration(300)
                .call(zoomRef.current.scaleBy, 1.7);
        }
    };

    // Update handleZoomOut function to allow for more dramatic zoom out

    const handleZoomOut = () => {
        if (!zoomRef.current || !svgRef.current) return;
        const currentScale = d3.zoomTransform(svgRef.current).k;
        const minScale = visualizationType === 'star' ? 0.2 : 0.05;

        // Don't zoom out beyond min scale
        if (currentScale * 0.25 >= minScale) {
            d3.select(svgRef.current)
                .transition()
                .duration(300)
                .call(zoomRef.current.scaleBy, 0.25);
        }
    };

    useEffect(() => {
        if (selectedCluster !== null && nodesDataRef.current) {
            const topicNode = nodesDataRef.current.find(
                (node) => node.size && node.id === selectedCluster
            );
            if (topicNode) {
                centerOnNode(topicNode);
            }
        }
    }, [selectedCluster]);

    // Function to center on a node with animation

    const centerOnNode = (nodeData) => {
        return new Promise((resolve) => {
            if (!zoomRef.current || !svgRef.current) {
                resolve();
                return;
            }

            const width = svgRef.current.clientWidth;
            const height = svgRef.current.clientHeight;

            // Handle different node data structures based on visualization type
            let x, y, scale;

            if (visualizationType === 'star') {
                // Star visualization - nodes have x, y coordinates directly
                scale = 2;
                x = width / 2 - nodeData.x * scale;
                y = height / 2 - nodeData.y * scale;
            } else {
                // Islands visualization - nodes are transformed groups
                // Find the cluster group by ID
                const clusterGroup = d3.select(svgRef.current)
                    .select(`.cluster:nth-child(${parseInt(nodeData.id) + 1})`);

                if (!clusterGroup.empty()) {
                    // Get the transform attribute values
                    const transform = clusterGroup.attr("transform");
                    const match = transform.match(/translate\(([-\d.]+),\s*([-\d.]+)\)/);

                    if (match) {
                        const clusterX = parseFloat(match[1]);
                        const clusterY = parseFloat(match[2]);

                        // Calculate center position including cluster dimensions
                        scale = 1;
                        x = width / 2 - (clusterX + nodeData.width / 2) * scale;
                        y = height / 2 - (clusterY + nodeData.height / 2) * scale;
                    } else {
                        // Fallback if transform not found
                        scale = 1.5;
                        x = width / 2;
                        y = height / 2;
                    }
                } else {
                    // Fallback if cluster not found
                    scale = 1.5;
                    x = width / 2;
                    y = height / 2;
                }
            }

            // Apply the transform with animation
            d3.select(svgRef.current)
                .transition()
                .duration(750)
                .call(
                    zoomRef.current.transform,
                    d3.zoomIdentity.translate(x, y).scale(scale)
                )
                .on("end", resolve);
        });
    };

    useEffect(() => {
        document.documentElement.classList.remove(
            "light",
            "dark",
            "hextech-nordic"
        );
        document.documentElement.classList.add(theme);
        localStorage.setItem("theme", theme);
    }, [theme]);

    const url_states = "http://127.0.0.1:5001/api/states";

    useEffect(() => {
        const fetchStates = async () => {
            try {
                const response = await fetch(`${url_states}?type=${chatType}`);
                const data = await response.json();
                setAvailableStates(data.states);
            } catch (error) {
                console.error("Error fetching states:", error);
            }
        };

        fetchStates();
    }, [chatType]);


    function createIslandsVisualization() {
        // Clear existing visualization
        const svg = d3.select(svgRef.current);
        svg.selectAll("*").remove();

        const width = svgRef.current.clientWidth;
        const height = svgRef.current.clientHeight;
        const padding = 100;

        // Helper function to measure text width
        const measureTextWidth = (text, fontSize) => {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `${fontSize}px sans-serif`;
            return context.measureText(text).width;
        };

        // Process and group clusters by category with optimized sizing
        const clusters = Object.entries(data.topics).map(([id, topic]) => {
            const conversations = data.chartData[0].data.filter(d => d.cluster === parseInt(id));

            // Calculate maximum text width among all conversation titles
            let maxConversationWidth = 0;
            conversations.forEach(conv => {
                const baseTitle = conv.title.replace(/ \(Branch \d+\)$/, '');
                const hasBranches = conversations.filter(c =>
                    c.title.replace(/ \(Branch \d+\)$/, '') === baseTitle
                ).length > 1;
                const textWidth = measureTextWidth(conv.title, 14);
                const totalWidth = textWidth + (hasBranches ? 55 : 35);
                maxConversationWidth = Math.max(maxConversationWidth, totalWidth);
            });

            // Calculate title width
            const titleWidth = measureTextWidth(topic.topic, 16) + 40;

            // Use the larger of title width or conversation width, plus minimal padding
            const clusterWidth = Math.max(titleWidth, maxConversationWidth) + 20;

            // Calculate height based on number of conversations
            const clusterHeight = Math.max(100, conversations.length * 30 + 60);

            return {
                id: parseInt(id),
                name: topic.topic,
                size: topic.size,
                coherence: topic.coherence,
                conversations: conversations,
                width: clusterWidth,
                height: clusterHeight
            };
        });

        // Enhanced force simulation with adjusted spacing
        const simulation = d3.forceSimulation(clusters)
            .force("charge", d3.forceManyBody().strength(-2000))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(d => {
                return Math.sqrt((d.width * d.width + d.height * d.height) / 4) + 30;
            }))
            .force("x", d3.forceX(width / 2).strength(0.1))
            .force("y", d3.forceY(height / 2).strength(0.1));

        // Create main group
        const g = svg.append("g");

        // Create cluster groups
        const clusterGroups = g.selectAll(".cluster")
            .data(clusters)
            .join("g")
            .attr("class", "cluster")
            .style("cursor", "pointer");

        // Add cluster backgrounds
        clusterGroups.append("rect")
            .attr("rx", 15)
            .attr("ry", 15)
            .attr("class", "cluster-bg")
            .attr("fill", d => `${getColor(d.id)}22`)
            .attr("stroke", d => getColor(d.id))
            .attr("stroke-width", 2)
            .attr("width", d => d.width)
            .attr("height", d => d.height);

        // Add cluster titles with theme-aware color
        clusterGroups.append("text")
            .attr("class", "cluster-title")
            .attr("x", 20)
            .attr("y", 30)
            .attr("fill", theme === "light" ? "#000" : "#fff")
            .attr("font-size", "16px")
            .attr("font-weight", "bold")
            .text(d => d.name);

        // Create conversation nodes
        clusterGroups.each(function (cluster) {
            const group = d3.select(this);
            const conversationGroup = group.append("g")
                .attr("class", "conversations")
                .attr("transform", "translate(20, 50)");

            // Count branches for each conversation
            const branchCounts = new Map();
            cluster.conversations.forEach(conv => {
                const baseTitle = conv.title.replace(/ \(Branch \d+\)$/, '');
                branchCounts.set(baseTitle, (branchCounts.get(baseTitle) || 0) + 1);
            });

            cluster.conversations.forEach((conv, i) => {
                const baseTitle = conv.title.replace(/ \(Branch \d+\)$/, '');
                const hasBranches = branchCounts.get(baseTitle) > 1;
                const branchCount = branchCounts.get(baseTitle) || 1;

                const convGroup = conversationGroup.append("g")
                    .attr("transform", `translate(0, ${i * 30})`)
                    .style("cursor", "pointer");

                // Main conversation circle
                convGroup.append("circle")
                    .attr("r", 6)
                    .attr("fill", getColor(cluster.id))
                    .attr("opacity", 0.8);

                if (hasBranches) {
                    // Add clear branch indicator
                    convGroup.append("circle")
                        .attr("r", 14)
                        .attr("fill", "none")
                        .attr("stroke", getColor(cluster.id))
                        .attr("stroke-width", 1.5)
                        .attr("stroke-dasharray", "3,3")
                        .attr("opacity", 0.8);

                    // Add branch count badge
                    convGroup.append("circle")
                        .attr("cx", 20)
                        .attr("cy", -8)
                        .attr("r", 8)
                        .attr("fill", getColor(cluster.id))
                        .attr("opacity", 0.9);

                    convGroup.append("text")
                        .attr("x", 20)
                        .attr("y", -8)
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                        .attr("fill", "#fff")
                        .attr("font-size", "10px")
                        .text(branchCount);
                }

                // Conversation title with theme-aware color
                convGroup.append("text")
                    .attr("x", hasBranches ? 35 : 15)
                    .attr("y", 4)
                    .attr("fill", theme === "light" ? "#000" : "#fff")
                    .attr("font-size", "14px")
                    .text(conv.title);

                convGroup.on("click", (event) => {
                    event.stopPropagation();
                    handleConversationClick({
                        title: baseTitle,
                        cluster: cluster.id,
                        hasReflection: conv.hasReflection,
                        branchCount: branchCount
                    }, event);
                });
            });
        });

        // Update positions from force simulation
        simulation.on("tick", () => {
            clusterGroups.attr("transform", d => {
                const x = d.x - d.width / 2;
                const y = d.y - d.height / 2;
                return `translate(${x},${y})`;
            });
        });

        const zoom = d3.zoom()
            .scaleExtent([0.02, 8])
            .on("zoom", (event) => g.attr("transform", event.transform));

        svg.call(zoom);
        zoomRef.current = zoom;

        // Calculate initial bounds
        const bounds = {
            width: d3.max(clusters, d => d.x + d.width / 2) - d3.min(clusters, d => d.x - d.width / 2),
            height: d3.max(clusters, d => d.y + d.height / 2) - d3.min(clusters, d => d.y - d.height / 2)
        };

        const initialScale = 0.02;
        const initialTransform = d3.zoomIdentity
            .translate(
                width / 2 - (bounds.width * initialScale) / 2,
                height / 2 - (bounds.height * initialScale) / 2
            )
            .scale(initialScale);

        svg.call(zoom.transform, initialTransform);
    }

    function createStarVisualization() {
        // Clear any existing visualization
        const svg = d3.select(svgRef.current);
        svg.selectAll("*").remove();

        // Add SVG defs for glow filter and patterns
        const defs = svg.append("defs");

        // Add glow filter
        const filter = defs.append("filter")
            .attr("id", "glow")
            .attr("x", "-50%")
            .attr("y", "-50%")
            .attr("width", "200%")
            .attr("height", "200%");

        filter.append("feGaussianBlur")
            .attr("stdDeviation", "3")
            .attr("result", "coloredBlur");

        const feMerge = filter.append("feMerge");
        feMerge.append("feMergeNode").attr("in", "coloredBlur");
        feMerge.append("feMergeNode").attr("in", "SourceGraphic");

        // Add branch indicator pattern
        defs.append("pattern")
            .attr("id", "branchPattern")
            .attr("patternUnits", "userSpaceOnUse")
            .attr("width", "4")
            .attr("height", "4")
            .append("path")
            .attr("d", "M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2")
            .attr("stroke", getThemeColors(theme).branchPattern)
            .attr("stroke-width", "1");

        const width = svgRef.current.clientWidth;
        const height = svgRef.current.clientHeight;
        const centerX = width / 2;
        const centerY = height / 2;

        // Star layout parameters
        const numPoints = 5;
        const outerRadius = Math.min(width, height) / 6;
        const innerRadius = outerRadius * 0.382;
        const nodeRadius = outerRadius * 1.5;

        // Generate star points
        const starPoints = [];
        for (let i = 0; i < numPoints * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = (i * Math.PI) / numPoints - Math.PI / 2;
            starPoints.push({
                x: centerX + radius * Math.cos(angle),
                y: centerY + radius * Math.sin(angle),
            });
        }

        // Analyze branches for each conversation
        const branchCounts = new Map();
        data.chartData[0].data.forEach(chat => {
            const baseTitle = chat.title.replace(/ \(Branch \d+\)$/, '');
            branchCounts.set(baseTitle, (branchCounts.get(baseTitle) || 0) + 1);
        });

        // Distribute topics around the star
        const topics = Object.entries(data.topics).map(([id, topic], index) => {
            const pointIndex = (index % numPoints) * 2;
            const angle = (pointIndex * Math.PI) / numPoints - Math.PI / 2;
            return {
                id: parseInt(id),
                name: topic.topic,
                size: topic.size,
                coherence: topic.coherence,
                x: centerX + nodeRadius * Math.cos(angle),
                y: centerY + nodeRadius * Math.sin(angle),
                angle: angle,
            };
        });

        // Position chat nodes
        const chats = data.chartData[0].data.map((d, i) => {
            const topic = topics.find((t) => t.id === d.cluster);
            const angle = topic.angle;
            const spreadDistance = nodeRadius * 0.4;
            const randomAngle = angle + ((Math.random() - 0.5) * Math.PI) / 6;
            const randomRadius = nodeRadius + (Math.random() - 0.5) * spreadDistance;

            return {
                ...d,
                id: `chat-${i}`,
                topicId: d.cluster,
                x: centerX + randomRadius * Math.cos(randomAngle),
                y: centerY + randomRadius * Math.sin(randomAngle),
            };
        });

        // Combine all nodes and store in ref
        const nodes = [...topics, ...chats];
        nodesDataRef.current = nodes;

        // Create links between topics and their chats
        const links = chats.map((chat) => ({
            source: topics.find((topic) => topic.id === chat.topicId),
            target: chat,
        }));

        // Create the main container group
        const g = svg.append("g").attr("class", "clusters");

        // Draw star shape outline
        const starPath = g
            .append("path")
            .attr(
                "d",
                (() => {
                    let path = `M ${starPoints[0].x} ${starPoints[0].y}`;
                    for (let i = 1; i < starPoints.length; i++) {
                        path += ` L ${starPoints[i].x} ${starPoints[i].y}`;
                    }
                    path += " Z";
                    return path;
                })()
            )
            .attr("stroke", getThemeColors(theme).starOutline)
            .attr("fill", "none")
            .attr("stroke-width", 1.5)
            .style("filter", "none")
            .style("opacity", 0.3);

        // Create links
        const link = g
            .append("g")
            .selectAll("line")
            .data(links)
            .join("line")
            .attr("stroke", getThemeColors(theme).link)
            .attr("stroke-opacity", 0.3)
            .attr("stroke-width", 0.5);

        // Create nodes group
        const node = g
            .append("g")
            .selectAll("g")
            .data(nodes)
            .join("g")
            .attr("class", "node")
            .attr("transform", d => `translate(${d.x},${d.y})`);

        // Base circle for all nodes
        node.append("circle")
            .attr("r", d => d.size ? 18 : 10)
            .attr("fill", d => {
                if (d.size) {
                    return getColor(d.id);
                } else if (d.hasReflection) {
                    return "#FFD700";
                } else {
                    return getColor(d.topicId);
                }
            })
            .attr("stroke", d => d.hasReflection ? "#FFD700" : null)
            .attr("stroke-width", d => d.hasReflection ? 1.5 : 0)
            .attr("fill-opacity", d => d.size ? 1 : 0.6);

        // Add branch indicators
        node.each(function (d) {
            if (!d.size) {
                const element = d3.select(this);
                const baseTitle = d.title?.replace(/ \(Branch \d+\)$/, '');
                const hasBranches = branchCounts.get(baseTitle) > 1;

                if (hasBranches) {
                    element.append("circle")
                        .attr("r", 14)
                        .attr("fill", "none")
                        .attr("stroke", getColor(d.topicId))
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", "3,3")
                        .attr("class", "branch-indicator")
                        .style("opacity", 0.7);

                    const branchPaths = [
                        "M -6,-6 L 0,-12 L 6,-6",
                        "M -6,6 L 0,12 L 6,6"
                    ];

                    element.selectAll(".branch-path")
                        .data(branchPaths)
                        .enter()
                        .append("path")
                        .attr("d", d => d)
                        .attr("stroke", getColor(d.topicId))
                        .attr("stroke-width", 1)
                        .attr("fill", "none")
                        .attr("class", "branch-path")
                        .style("opacity", 0.7);
                }
            }
        });

        // Add labels for topic nodes with theme-aware color
        node.filter(d => d.size)
            .append("text")
            .attr("dy", "-1.5em")
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .attr("fill", theme === "light" ? "#000" : "#fff")
            .attr("opacity", 0.8)
            .text(d => d.name);

        // Add event handlers
        node
            .style("cursor", "pointer")
            .on("mouseover", (event, d) => {
                const baseTitle = d.title?.replace(/ \(Branch \d+\)$/, '');
                const branchCount = !d.size ? branchCounts.get(baseTitle) || 1 : null;

                setHoveredPoint({
                    x: event.pageX,
                    y: event.pageY,
                    topic: d.size ? data.topics[d.id].topic : data.topics[d.topicId].topic,
                    title: d.title || d.name,
                    hasReflection: d.hasReflection,
                    branchCount: branchCount > 1 ? `${branchCount} branches` : 'Single thread',
                    coherence: d.size ? data.topics[d.id].coherence : null,
                });
            })
            .on("mouseout", () => setHoveredPoint(null))
            .on("click", (event, d) => {
                event.stopPropagation();
                if (d.size) {
                    setSelectedCluster(d.id);
                    centerOnNode(d);
                } else {
                    handleConversationClick(
                        {
                            title: d.title,
                            cluster: d.topicId,
                            hasReflection: d.hasReflection
                        },
                        event
                    );
                }
            });

        // Force simulation setup
        const simulation = d3
            .forceSimulation(nodes)
            .force(
                "link",
                d3
                    .forceLink(links)
                    .id((d) => d.id)
                    .distance(30)
                    .strength(0.3)
            )
            .force(
                "charge",
                d3.forceManyBody().strength((d) => (d.size ? -300 : -30))
            )
            .force(
                "collide",
                d3
                    .forceCollide()
                    .radius((d) => (d.size ? 30 : hasBranches(d) ? 18 : 12))
                    .strength(0.8)
            )
            .force("star", (alpha) => {
                nodes.forEach((node) => {
                    if (node.size) {
                        const angle = (topics.findIndex((t) => t.id === node.id) * 2 * Math.PI) / numPoints - Math.PI / 2;
                        const targetX = centerX + nodeRadius * Math.cos(angle);
                        const targetY = centerY + nodeRadius * Math.sin(angle);
                        node.vx += (targetX - node.x) * alpha * 0.3;
                        node.vy += (targetY - node.y) * alpha * 0.3;
                    }
                });
            })
            .on("tick", () => {
                link
                    .attr("x1", (d) => d.source.x)
                    .attr("y1", (d) => d.source.y)
                    .attr("x2", (d) => d.target.x)
                    .attr("y2", (d) => d.target.y);

                node.attr("transform", d => `translate(${d.x},${d.y})`);
            });

        function hasBranches(d) {
            if (d.size) return false;
            const baseTitle = d.title?.replace(/ \(Branch \d+\)$/, '');
            return branchCounts.get(baseTitle) > 1;
        }

        const zoom = d3
            .zoom()
            .scaleExtent([0.08, 8])
            .on("zoom", (event) => g.attr("transform", event.transform));

        svg.call(zoom);
        zoomRef.current = zoom;

        const initialScale = 0.08;
        const padding = 40;
        const visWidth = width - padding;
        const visHeight = height - padding;

        const initialTransform = d3.zoomIdentity
            .translate(visWidth / 2, visHeight / 2)
            .scale(initialScale)
            .translate(-centerX, -centerY);

        svg.call(zoom.transform, initialTransform);

        // Cleanup function
        return () => {
            simulation.stop();
            zoomRef.current = null;
            nodesDataRef.current = null;
        };
    }


    const handleConversationClick = async (point, event) => {
        try {
          const baseTitle = point.title.replace(/ \(Branch \d+\)$/, '');

          // Get the branched data
          const messageData = await fetchAllMessages(baseTitle, chatType);

          if (!messageData || !messageData.branches) {
            console.error('Failed to fetch conversation data');
            return;
          }

          // Build nodes structure for TangentChat
          const nodes = buildConversationNodes(messageData, baseTitle);
          console.log("Processed nodes:", nodes);

          if (!nodes || nodes.length === 0) {
            console.error('No valid nodes created from message data');
            return;
          }

          // Get click position or use window center
          const clickPosition = {
            x: event?.clientX || window.innerWidth / 2,
            y: event?.clientY || window.innerHeight / 2
          };

          // Update the parent component's state through props
          window.dispatchEvent(new CustomEvent('openConversation', {
            detail: {
              nodes,
              position: clickPosition
            }
          }));

        } catch (error) {
          console.error('Error in conversation click handler:', error);
        }
      };

    async function fetchAndProcessBranchedConversation(title, chatType) {
        try {
            // Fetch all messages including branch information
            const response = await fetch(
                `http://127.0.0.1:5001/api/messages_all/${encodeURIComponent(title)}?type=${chatType}`
            );
            const data = await response.json();

            if (!data.branches) {
                console.error('No branches data found');
                return null;
            }

            // Create nodes structure for TangentChat
            const nodes = [];
            const messageToNodeMap = new Map();
            let nodeCounter = 1;

            // First, create the main thread node (branch '0')
            const mainBranch = data.branches['0'];
            if (mainBranch) {
                const mainNode = {
                    id: nodeCounter++,
                    type: 'main',
                    title: title,
                    messages: mainBranch.map(msg => ({
                        role: msg.sender === 'human' ? 'user' : 'assistant',
                        content: msg.text,
                        messageId: msg.message_id
                    })),
                    branchId: '0',
                    x: 0,
                    y: 0
                };
                nodes.push(mainNode);

                // Map each message ID to this node
                mainBranch.forEach(msg => {
                    messageToNodeMap.set(msg.message_id, mainNode.id);
                });
            }

            // Then create all branch nodes
            Object.entries(data.branches).forEach(([branchId, messages]) => {
                if (branchId === '0') return; // Skip main thread as it's already processed

                const firstMessage = messages[0];
                if (!firstMessage || !firstMessage.parent_message_id) return;

                // Find parent node via message map
                const parentNodeId = messageToNodeMap.get(firstMessage.parent_message_id);
                const parentNode = nodes.find(n => n.id === parentNodeId);

                if (!parentNode) {
                    console.warn(`Parent node not found for branch ${branchId}`);
                    return;
                }

                // Find index of parent message in parent node
                const parentMessageIndex = parentNode.messages.findIndex(
                    msg => msg.messageId === firstMessage.parent_message_id
                );

                // Create branch node
                const branchNode = {
                    id: nodeCounter++,
                    type: 'branch',
                    title: `${title} (Branch ${branchId})`,
                    messages: messages.map(msg => ({
                        role: msg.sender === 'human' ? 'user' : 'assistant',
                        content: msg.text,
                        messageId: msg.message_id
                    })),
                    parentId: parentNodeId,
                    parentMessageIndex: parentMessageIndex,
                    branchId: branchId,
                    // Get full context including parent messages
                    contextMessages: parentNode.messages.slice(0, parentMessageIndex + 1).concat(
                        messages.map(msg => ({
                            role: msg.sender === 'human' ? 'user' : 'assistant',
                            content: msg.text,
                            messageId: msg.message_id
                        }))
                    ),
                    x: parentNode.x + 300, // Position relative to parent
                    y: parentNode.y + (parentMessageIndex * 50) // Stack vertically based on branch point
                };
                nodes.push(branchNode);

                // Map all messages in this branch to the branch node
                messages.forEach(msg => {
                    messageToNodeMap.set(msg.message_id, branchNode.id);
                });
            });

            console.log('Processed nodes structure:', nodes);
            return nodes;

        } catch (error) {
            console.error('Error processing branched conversation:', error);
            return null;
        }
    }

    // Then, enhance the visualization of branched conversations in MainDashboard
    function createBranchIndicator(group, x, y, color, branchCount) {
        // Main dot
        group.append('circle')
            .attr('cx', x)
            .attr('cy', y)
            .attr('r', 6)
            .attr('fill', color)
            .attr('opacity', 0.8);

        if (branchCount > 1) {
            // Outer ring for branches
            group.append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', 12)
                .attr('fill', 'none')
                .attr('stroke', color)
                .attr('stroke-width', 1.5)
                .attr('stroke-dasharray', '3,3')
                .attr('opacity', 0.6);

            // Branch count indicator
            group.append('text')
                .attr('x', x + 16)
                .attr('y', y)
                .attr('dy', '0.3em')
                .attr('fill', getThemeColors(theme).text)
                .attr('font-size', '12px')
                .text(`${branchCount} branches`);

            // Small branch indicators
            const angleStep = (2 * Math.PI) / branchCount;
            for (let i = 0; i < branchCount; i++) {
                const angle = i * angleStep;
                const bx = x + Math.cos(angle) * 12;
                const by = y + Math.sin(angle) * 12;

                group.append('circle')
                    .attr('cx', bx)
                    .attr('cy', by)
                    .attr('r', 3)
                    .attr('fill', color)
                    .attr('opacity', 0.4);
            }
        }
    }

    const buildConversationNodes = (responseData, chatTitle) => {
        if (!responseData || !responseData.branches) {
            console.error('Invalid response data structure');
            return [];
        }

        const nodes = [];
        const messageToNodeMap = new Map();
        let nodeIdCounter = 1;

        // First create the main thread (branch '0')
        const mainBranch = responseData.branches['0'];
        if (mainBranch) {
            const mainNode = {
                id: nodeIdCounter++,
                title: chatTitle,
                messages: mainBranch.map(msg => ({
                    role: msg.sender === 'human' ? 'user' : 'assistant',
                    content: msg.text,
                    messageId: msg.message_id
                })),
                type: 'main',
                branchId: '0'
            };
            nodes.push(mainNode);
            mainBranch.forEach(msg => messageToNodeMap.set(msg.message_id, mainNode.id));
        }

        // Then create all branch nodes
        Object.entries(responseData.branches).forEach(([branchId, messages]) => {
            if (branchId === '0') return; // Skip main thread

            const firstMessage = messages[0];
            if (!firstMessage?.parent_message_id) return;

            const parentNodeId = messageToNodeMap.get(firstMessage.parent_message_id);
            const parentNode = nodes.find(n => n.id === parentNodeId);

            if (!parentNode) {
                console.warn(`Parent node not found for branch ${branchId}`);
                return;
            }

            const parentMessageIndex = parentNode.messages.findIndex(
                msg => msg.messageId === firstMessage.parent_message_id
            );

            const branchNode = {
                id: nodeIdCounter++,
                title: chatTitle,
                messages: messages.map(msg => ({
                    role: msg.sender === 'human' ? 'user' : 'assistant',
                    content: msg.text,
                    messageId: msg.message_id
                })),
                type: 'branch',
                parentId: parentNodeId,
                parentMessageIndex: parentMessageIndex >= 0 ? parentMessageIndex : 0,
                branchId: branchId
            };

            nodes.push(branchNode);
            messages.forEach(msg => messageToNodeMap.set(msg.message_id, branchNode.id));
        });

        console.log("Built nodes:", nodes); // Debug output
        return nodes;
    };

    // Helper function to truncate text
    function truncateText(text, maxWidth, font) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        context.font = font;

        if (context.measureText(text).width <= maxWidth) {
            return text;
        }

        let truncated = text;
        while (context.measureText(truncated + '...').width > maxWidth && truncated.length > 0) {
            truncated = truncated.slice(0, -1);
        }
        return truncated + '...';
    }

    // Helper function to calculate bounds of all clusters
    function calculateBounds(clusters) {
        const positions = clusters.map(d => ({
            left: d.x - d.width / 2,
            right: d.x + d.width / 2,
            top: d.y - d.height / 2,
            bottom: d.y + d.height / 2
        }));

        return {
            x: d3.min(positions, d => d.left),
            y: d3.min(positions, d => d.top),
            width: d3.max(positions, d => d.right) - d3.min(positions, d => d.left),
            height: d3.max(positions, d => d.bottom) - d3.min(positions, d => d.top)
        };
    }

    // Helper function to validate message data structure
    const isValidMessageData = (data) => {
        return data &&
            typeof data === 'object' &&
            data.branches &&
            Object.keys(data.branches).length > 0;
    };
    const createVisualization = useCallback(() => {
        if (!data || !svgRef.current) return;

        // Clear existing visualization
        const svg = d3.select(svgRef.current);
        svg.selectAll("*").remove();

        // Force layout recalculation by updating dimensions
        const width = svgRef.current.clientWidth;
        const height = svgRef.current.clientHeight;
        svg
            .attr("width", width)
            .attr("height", height);

        if (visualizationType === 'star') {
            createStarVisualization();
        } else if (visualizationType === 'islands') {
            createIslandsVisualization();
        }
    }, [data, theme, selectedPoints, visualizationType, chatType]);

    const handleTopicSelect = (clusterId) => {
        setSelectedCluster(parseInt(clusterId));
    };

    const handleTabChange = (value) => {
        setActiveTab(value);
        // Allow DOM to update before recreating visualization
        if (value === "map" && data) {
            setTimeout(() => {
                createVisualization();
            }, 0);
        }
    };

    const handleDataUpdate = (newData) => {
        console.log("Updating data with:", newData);
        setData(newData);

        // Trigger visualization refresh
        if (activeTab === "map") {
            setTimeout(() => {
                createVisualization();
            }, 0);
        }
    };

    useEffect(() => {
        const fetchData = async () => {
            setIsLoading(true);
            try {
                const response = await fetch(url_visualization);
                const responseData = await response.json();
                const chatsWithReflections = new Set(
                    responseData.chats_with_reflections
                );

                const chartData = [
                    {
                        id: "points",
                        data: responseData.points.map((point, i) => ({
                            x: point[0],
                            y: point[1],
                            cluster: responseData.clusters[i],
                            title: responseData.titles[i],
                            hasReflection: chatsWithReflections.has(responseData.titles[i]),
                        })),
                    },
                ];

                setData({
                    chartData,
                    topics: responseData.topics,
                });
            } catch (error) {
                console.error("Error fetching data:", error);
            } finally {
                setIsLoading(false);
            }
        };

        fetchData();
    }, []);

    useEffect(() => {
        if (activeTab === "map" && data) {
            // Clear previous visualization
            if (svgRef.current) {
                const svg = d3.select(svgRef.current);
                svg.selectAll("*").remove();
            }

            createVisualization();
        }

        return () => {
            if (svgRef.current) {
                const svg = d3.select(svgRef.current);
                svg.selectAll("*").remove();
            }
        };
    }, [activeTab, data, chatType, createVisualization, visualizationType, theme]);


    if (isLoading) {
        return (
            <div className="flex h-screen items-center justify-center">
                <div className="h-8 w-8 animate-spin rounded-full border-4 border-muted border-t-primary"></div>
            </div>
        );
    }



    // Ensure this function fetches all messages, including branches
    const fetchAllMessages = async (title, chatType = 'claude') => {
        const encodedTitle = encodeURIComponent(title);
        try {
            const response = await axios.get(
                `http://127.0.0.1:5001/api/messages_all/${encodedTitle}?type=${chatType}`,
                {
                    validateStatus: function (status) {
                        return status < 500;
                    },
                }
            );
            if (response.status === 200) {
                return response.data;
            }
            return null;
        } catch (error) {
            console.error(`Error fetching all messages:`, error);
            return null;
        }
    };


    const getReflectionForChat = (chat) => {
        if (!chat || !data) return null;
        const clusterId = chat.cluster.toString();
        const reflection = data.topics[clusterId]?.reflection;
        return reflection?.replace(/<\/?antArtifact[^>]*>/g, "") || null;
    };


    return (
        <div className="h-screen flex flex-col">
            <main className="flex-1 relative">
                <VisualizationPanel {...{
                    activeTab,
                    handleTabChange,
                    chatType,
                    setChatType,
                    handleDataUpdate,
                    handleRefresh,
                    handleZoomIn,
                    handleZoomOut,
                    svgRef,
                    createVisualization,
                    data: visualizationData,
                    visualizationType,
                    setVisualizationType,
                    sortBy,
                    setSortBy,
                    selectedCluster,
                    handleTopicSelect,
                    getColor
                }} />
            </main>

            {showReflectionDialog && <ReflectionDialog
                open={showReflectionDialog}
                onOpenChange={setShowReflectionDialog}
                conversation={selectedConversation}
                reflection={selectedConversation ? getReflectionForChat(selectedConversation) : null}
            />}
            <HoverTooltip hoveredPoint={hoveredPoint} />
        </div>
    );

};

export default MainDashboard;




// ========================================
// File: simplified-ui/src/components/MessageNavigator.jsx
// ========================================

import React, { useEffect } from 'react';
import { cn } from '../components/lib/utils';
import { Expand, Minimize } from 'lucide-react';

export const MessageNavigator = ({
  currentNode,
  currentIndex,
  totalMessages,
  onNavigate,
  branches,
  isMessageExpanded,
  onToggleExpand
}) => {
  // Handle keyboard shortcuts for expansion
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Only handle if not typing in an input
      if (document.activeElement.tagName === 'INPUT' || 
          document.activeElement.tagName === 'TEXTAREA' ||
          !currentNode) return;

      // Handle 'e' key for expansion toggle
      if (e.key.toLowerCase() === 'e') {
        e.preventDefault(); // Prevent any default 'e' key behavior
        onToggleExpand(currentIndex);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [currentIndex, onToggleExpand, currentNode]);

  if (!currentNode) return null;

  const canGoUp = currentIndex > 0;
  const canGoDown = currentIndex < totalMessages - 1;
  const hasLeft = branches.left.length > 0 || branches.parent?.position === 'left';
  const hasRight = branches.right.length > 0 || branches.parent?.position === 'right';

  return (
    <div className={cn(
      "relative bottom-2 right-2 rounded-md text-[10px]",
      "bg-background/80 backdrop-blur-sm supports-[backdrop-filter]:bg-background/60",
      "shadow-sm border border-border"
    )}>
      <div className="flex items-center gap-1">
        {/* Navigation buttons remain the same */}
        <div className="relative">
          <button 
            onClick={() => onNavigate('left')}
            className={cn(
              "px-1 rounded transition-colors",
              hasLeft
                ? "bg-primary/20 text-primary hover:bg-primary/30 cursor-pointer" 
                : "bg-muted text-muted-foreground cursor-not-allowed"
          )}>A</button>
          {branches.left.length > 1 && (
            <span className="absolute -top-2 -right-1 text-[8px] text-primary">
              {branches.left.length}
            </span>
          )}
        </div>
        
        <div className="flex flex-col gap-0.5">
          <button 
            onClick={() => onNavigate('up')}
            className={cn(
              "px-1 rounded transition-colors",
              canGoUp
                ? "bg-primary/20 text-primary hover:bg-primary/30 cursor-pointer" 
                : "bg-muted text-muted-foreground cursor-not-allowed"
          )}>W</button>
          <button 
            onClick={() => onNavigate('down')}
            className={cn(
              "px-1 rounded transition-colors",
              canGoDown
                ? "bg-primary/20 text-primary hover:bg-primary/30 cursor-pointer" 
                : "bg-muted text-muted-foreground cursor-not-allowed"
          )}>S</button>
        </div>

        <div className="relative">
          <button 
            onClick={() => onNavigate('right')}
            className={cn(
              "px-1 rounded transition-colors",
              hasRight
                ? "bg-primary/20 text-primary hover:bg-primary/30 cursor-pointer" 
                : "bg-muted text-muted-foreground cursor-not-allowed"
          )}>D</button>
          {branches.right.length > 1 && (
            <span className="absolute -top-2 -right-1 text-[8px] text-primary">
              {branches.right.length}
            </span>
          )}
        </div>

        {/* Updated Expand/Collapse button */}
        <button
          onClick={(e) => {
            e.stopPropagation();
            onToggleExpand(currentIndex);
          }}
          className={cn(
            "p-1 rounded transition-colors",
            "bg-primary/20 text-primary hover:bg-primary/30",
            "flex items-center gap-1"
          )}
          title="Press 'E' to toggle expansion"
        >
          {isMessageExpanded ? (
            <>
              <Minimize className="w-3 h-3" />
              <span>E</span>
            </>
          ) : (
            <>
              <Expand className="w-3 h-3" />
              <span>E</span>
            </>
          )}
        </button>

        <span className="text-muted-foreground px-1">
          {currentIndex + 1}/{totalMessages}
        </span>
        <span className={cn(
          "px-1 rounded",
          "bg-primary/20 text-primary"
        )}>
          {currentNode.type === 'main' ? 'M' : `B${currentNode.id}`}
        </span>
      </div>
    </div>
  );
};

export default MessageNavigator;


// ========================================
// File: simplified-ui/src/components/ModelCard.jsx
// ========================================

// ModelCard.jsx
import React from "react";
import {
  Info,
  Trash2,
  Terminal,
  Eye,
  Network,
  Bot,
  CircuitBoard,
  Brain,
  Activity,
  Download,
} from "lucide-react";
import {
  Card,
  CardHeader,
  CardTitle,
  CardContent,
  CardDescription,
  Button,
  Tooltip,
  TooltipContent,
  TooltipTrigger,
  TooltipProvider,
  Badge,
} from "./index";

export const ModelCard = ({
  model,
  isRunning,
  onInfoClick,
  onDeleteClick,
  onPullClick,
  modelType,
  detailedView = false,
  isLibraryModel = false,
}) => {
  const getModelIcon = () => {
    switch (modelType) {
      case "text":
        return <Terminal className="h-5 w-5 text-blue-500" />;
      case "vision":
        return <Eye className="h-5 w-5 text-purple-500" />;
      case "embedding":
        return <Network className="h-5 w-5 text-green-500" />;
      default:
        return <Bot className="h-5 w-5 text-gray-500" />;
    }
  };

  const formatSize = (size) => {
    if (!size) return "N/A";
    const sizeNum = parseInt(size);
    if (sizeNum >= 1073741824) {
      return `${(sizeNum / 1073741824).toFixed(1)} GB`;
    } else if (sizeNum >= 1048576) {
      return `${(sizeNum / 1048576).toFixed(1)} MB`;
    } else if (sizeNum >= 1024) {
      return `${(sizeNum / 1024).toFixed(1)} KB`;
    }
    return `${sizeNum} Bytes`;
  };

  const handleCardClick = (e) => {
    if (!e.target.closest("button")) {
      onInfoClick?.(model.name);
    }
  };

  return (
    <Card
      className="w-full h-full flex flex-col justify-between transition-all hover:shadow-lg cursor-pointer"
      onClick={handleCardClick}
    >
      <CardHeader className="p-4 flex items-start justify-between">
        <div className="flex items-center gap-2">
          {getModelIcon()}
          <div>
            <CardTitle className="text-sm font-semibold">{model.name}</CardTitle>
            {detailedView && (
              <CardDescription className="text-xs">
                {model.architecture || "Architecture N/A"}
              </CardDescription>
            )}
          </div>
        </div>
        <div className="flex items-center gap-1">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-8 w-8"
                  onClick={(e) => {
                    e.stopPropagation();
                    onInfoClick?.(model.name);
                  }}
                  aria-label="Show Info"
                >
                  <Info className="h-4 w-4" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>Show Info</TooltipContent>
            </Tooltip>
          </TooltipProvider>
          {isLibraryModel ? (
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-8 w-8"
                    onClick={(e) => {
                      e.stopPropagation();
                      onPullClick?.(model.name);
                    }}
                    aria-label="Pull Model"
                  >
                    <Download className="h-4 w-4" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>Pull Model</TooltipContent>
              </Tooltip>
            </TooltipProvider>
          ) : (
            !isRunning && (
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="h-8 w-8"
                      onClick={(e) => {
                        e.stopPropagation();
                        onDeleteClick?.(model.name);
                      }}
                      aria-label="Delete Model"
                    >
                      <Trash2 className="h-4 w-4 text-destructive" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>Delete Model</TooltipContent>
                </Tooltip>
              </TooltipProvider>
            )
          )}
        </div>
      </CardHeader>
      {detailedView && (
        <CardContent className="px-4 pb-4 pt-0">
          <div className="grid grid-cols-2 gap-2 text-sm">
            <div className="flex items-center gap-2">
              <CircuitBoard className="h-3 w-3 text-muted-foreground" />
              <span className="text-muted-foreground">
                {model.details?.parameter_size || "N/A"}
              </span>
            </div>
            <div className="flex items-center gap-2">
              <Brain className="h-3 w-3 text-muted-foreground" />
              <span className="text-muted-foreground">
                {formatSize(model.size)}
              </span>
            </div>
            <div className="flex items-center gap-2">
              <Activity className="h-3 w-3 text-muted-foreground" />
              <span className="text-muted-foreground">
                {model.details?.quantization_level || "N/A"}
              </span>
            </div>
          </div>
          {model.tags && (
            <div className="mt-3 flex flex-wrap gap-2">
              {model.tags.slice(0, 3).map((tag) => (
                <Badge key={tag} variant="secondary" className="text-xs">
                  {tag.split(":")[1]}
                </Badge>
              ))}
              {model.tags.length > 3 && (
                <Badge variant="outline" className="text-xs">
                  +{model.tags.length - 3} more
                </Badge>
              )}
            </div>
          )}
        </CardContent>
      )}
      {isRunning && (
        <Badge variant="secondary" className="absolute top-2 right-2 h-6">
          Active
        </Badge>
      )}
    </Card>
  );
};



// ========================================
// File: simplified-ui/src/components/ModelStatus.jsx
// ========================================

import React, { useState, useRef, useEffect } from 'react';
import { Bot, X, ChevronLeft, ChevronRight } from 'lucide-react';
import { cn } from './lib/utils';

export const ModelStatus = ({
  selectedModel,
  isLoading,
  temperature = 0.7,
  onTemperatureChange,
  models = [],
  onModelSelect,
  className,
  containerWidth
}) => {
  const [isSelecting, setIsSelecting] = useState(false);
  const [isClosing, setIsClosing] = useState(false);
  const [tempSelection, setTempSelection] = useState(null);
  const [isEditingTemp, setIsEditingTemp] = useState(false);
  const [tempValue, setTempValue] = useState(temperature.toString());
  const [canScrollLeft, setCanScrollLeft] = useState(false);
  const [canScrollRight, setCanScrollRight] = useState(false);
  const scrollContainerRef = useRef(null);
  const tempInputRef = useRef(null);
  const [modelName, modelSize] = (selectedModel || '').split(':');

  // Calculate max width based on container width
  const getMaxWidth = () => {
    if (!containerWidth) return 'w-[220px]';
    return `w-[${Math.min(containerWidth - 40, 220)}px]`;
  };

  const handleTempClick = (e) => {
    e.stopPropagation();
    setIsEditingTemp(true);
  };

  const handleTempChange = (e) => {
    const value = e.target.value;
    if (value === '' || (value >= 0 && value <= 2 && /^\d*\.?\d*$/.test(value))) {
      setTempValue(value);
    }
  };

  const handleTempBlur = () => {
    setIsEditingTemp(false);
    const newTemp = Math.min(Math.max(parseFloat(tempValue) || 0, 0), 2);
    setTempValue(newTemp.toString());
    onTemperatureChange?.(newTemp);
  };

  const handleTempKeyDown = (e) => {
    if (e.key === 'Enter') {
      handleTempBlur();
    }
    e.stopPropagation();
  };

  useEffect(() => {
    if (isEditingTemp && tempInputRef.current) {
      tempInputRef.current.focus();
    }
  }, [isEditingTemp]);

  const updateScrollButtons = () => {
    if (scrollContainerRef.current) {
      const { scrollLeft, scrollWidth, clientWidth } = scrollContainerRef.current;
      setCanScrollLeft(scrollLeft > 0);
      setCanScrollRight(scrollLeft + clientWidth < scrollWidth);
    }
  };

  useEffect(() => {
    updateScrollButtons();
    window.addEventListener('resize', updateScrollButtons);
    return () => window.removeEventListener('resize', updateScrollButtons);
  }, [isSelecting]);

  const handleScroll = (direction) => {
    if (scrollContainerRef.current) {
      const scrollAmount = direction === 'left' ? -200 : 200;
      scrollContainerRef.current.scrollBy({
        left: scrollAmount,
        behavior: 'smooth'
      });
    }
  };

  const handleSelect = (modelName) => {
    setTempSelection(modelName);
  };

  const handleCancel = () => {
    setIsClosing(true);
    setTimeout(() => {
      setIsClosing(false);
      setIsSelecting(false);
      setTempSelection(null);
    }, 200);
  };

  const handleConfirm = () => {
    if (tempSelection) {
      onModelSelect(tempSelection);
    }
    handleCancel();
  };

  // Calculate modal width based on container width
  const getModalWidth = () => {
    if (!containerWidth) return 'w-full';
    if (containerWidth <= 240) return 'w-[220px]';
    if (containerWidth <= 400) return 'w-[380px]';
    return 'w-[500px]';
  };

  if (isSelecting) {
    return (
      <div className={cn(
        "p-2 rounded-md text-sm",
        "bg-background/80 backdrop-blur-sm supports-[backdrop-filter]:bg-background/60",
        "shadow-sm border border-border",
        "transition-all duration-200",
        getModalWidth(),
        isClosing ? "opacity-0 scale-95" : "opacity-100 scale-100",
        "w-full",
        className
      )}>
        <div className="flex flex-col gap-2">
          <div className="flex items-center justify-between">
            <span className="text-xs text-muted-foreground">Select Model</span>
            <button
              onClick={handleCancel}
              className="p-1 hover:bg-secondary/50 rounded-md"
            >
              <X className="h-4 w-4" />
            </button>
          </div>

          <div className="relative">
            {canScrollLeft && (
              <button
                onClick={() => handleScroll('left')}
                className="absolute left-0 top-1/2 -translate-y-1/2 z-10 p-1 hover:bg-secondary/50 rounded-full bg-background/80 backdrop-blur-sm"
              >
                <ChevronLeft className="h-4 w-4" />
              </button>
            )}

            <div
              ref={scrollContainerRef}
              onScroll={updateScrollButtons}
              className="overflow-x-auto flex gap-2 px-6 scrollbar-hide scroll-smooth"
            >
              {models.map((model) => (
                <button
                  key={model.name}
                  onClick={() => handleSelect(model.name)}
                  className={cn(
                    "px-3 py-1.5 rounded-md whitespace-nowrap",
                    "transition-colors duration-200",
                    tempSelection === model.name ? "bg-primary text-primary-foreground" : "hover:bg-secondary/50"
                  )}
                >
                  {model.name}
                </button>
              ))}
            </div>

            {canScrollRight && (
              <button
                onClick={() => handleScroll('right')}
                className="absolute right-0 top-1/2 -translate-y-1/2 z-10 p-1 hover:bg-secondary/50 rounded-full bg-background/80 backdrop-blur-sm"
              >
                <ChevronRight className="h-4 w-4" />
              </button>
            )}
          </div>

          <div className="flex justify-end gap-2 pt-2 border-t">
            <button
              onClick={handleCancel}
              className="px-3 py-1 text-sm rounded-md hover:bg-secondary/50"
            >
              Cancel
            </button>
            <button
              onClick={handleConfirm}
              className={cn(
                "px-3 py-1 text-sm rounded-md",
                tempSelection
                  ? "bg-primary text-primary-foreground hover:bg-primary/90"
                  : "opacity-50 cursor-not-allowed bg-secondary"
              )}
              disabled={!tempSelection}
            >
              Confirm
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div
      onClick={() => setIsSelecting(true)}
      className={cn(
        "p-1.5 rounded-md text-[10px] cursor-pointer",
        "bg-background/80 backdrop-blur-sm supports-[backdrop-filter]:bg-background/60",
        "shadow-sm border border-border",
        "hover:bg-secondary/50 transition-colors duration-200",
        getMaxWidth(),
        "w-full",
        className
      )}
    >
      <div className="flex items-center gap-2">
        <div className="flex items-center gap-1 min-w-0">
          <Bot className="h-3 w-3 text-primary flex-shrink-0" />
          <span className={cn(
            "rounded truncate",
            "bg-primary/20 text-primary"
          )}>
            {modelName || 'No model selected'}
          </span>
        </div>

        {modelSize && (
          <span className="text-muted-foreground border-l border-border pl-2 flex-shrink-0">
            {modelSize}
          </span>
        )}

        <div
          className="text-muted-foreground border-l border-border pl-2 flex-shrink-0"
          onClick={(e) => e.stopPropagation()}
        >
          {isEditingTemp ? (
            <input
              ref={tempInputRef}
              type="text"
              value={tempValue}
              onChange={handleTempChange}
              onBlur={handleTempBlur}
              onKeyDown={handleTempKeyDown}
              className="w-8 bg-transparent text-center outline-none"
              onClick={(e) => e.stopPropagation()}
            />
          ) : (
            <span onClick={handleTempClick}>
              T={temperature}
            </span>
          )}
        </div>

        {isLoading && (
          <div className="w-2 h-2 rounded-full bg-primary/80 animate-pulse flex-shrink-0" />
        )}
      </div>
    </div>
  );
};

export default ModelStatus;


// ========================================
// File: simplified-ui/src/components/ModelsModal.jsx
// ========================================

import {
  motion,
  AnimatePresence,
} from "framer-motion";
import React, { useEffect, useState } from "react";
import {
  X,
  Bot,
  Terminal,
  Eye,
  Network,
  RefreshCw,
  Loader2,
  GripHorizontal,
  Plus,
  Copy,
  Upload,
  Cpu,
  Search,
  AlertCircle,
} from "lucide-react";
import {
  CardTitle,
  CardContent,
  Button,
  ScrollArea,
  Badge,
  Input,
  Separator,
  Textarea,
} from "./index";
import { Alert, AlertDescription } from "./ui/alert";
import {
  Select,
  SelectTrigger,
  SelectContent,
  SelectItem,
  SelectValue,
} from "./ui/select";
import { Tabs, TabsList, TabsTrigger, TabsContent } from "./ui/tabs";
import { Card, CardHeader } from "./ui/card";
import { ModelCard } from "./ModelCard";
import { cn } from "./lib/utils";

const ModelsModal = ({
  isOpen,
  onClose,
  models,
  runningModels,
  detailedView,
  setDetailedView,
  onModelClick,
  onDeleteModel,
  pullModelName,
  setPullModelName,
  isPulling,
  onPullModel,
  pullStatus,
  onCreateModel,
  isCreating,
  createStatus,
  onCopyModel,
  isCopying,
  copyStatus,
  onPushModel,
  isPushing,
  pushStatus,
  onGenerateEmbeddings,
  isEmbedding,
  embeddingStatus,
}) => {
  const [activeTab, setActiveTab] = useState("local");
  const [libraryModels, setLibraryModels] = useState([]);
  const [isLoadingLibrary, setIsLoadingLibrary] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [modelTypeFilter, setModelTypeFilter] = useState("all");
  const [error, setError] = useState("");
  const [copySourceModel, setCopySourceModel] = useState("");
  const [copyDestinationModel, setCopyDestinationModel] = useState("");
  const [embeddingModelName, setEmbeddingModelName] = useState("");
  const [embeddingInput, setEmbeddingInput] = useState("");
  const [createModelName, setCreateModelName] = useState("");
  const [createModelFile, setCreateModelFile] = useState("");
  const [pushModelName, setPushModelName] = useState("");

  const handleDragEnd = (event, info) => {
    const threshold = window.innerHeight * 0.3;
    if (info.offset.y > threshold) {
      onClose();
    }
  };

  const categorizeModels = (modelsList) => {
    return modelsList.reduce(
      (acc, model) => {
        if (model.architecture === "bert" || model.name.includes("minilm")) {
          acc.embeddings.push(model);
        } else if (
          model.architecture === "mllama" ||
          model.name.includes("vision")
        ) {
          acc.vision.push(model);
        } else {
          acc.text.push(model);
        }
        return acc;
      },
      { text: [], vision: [], embeddings: [] }
    );
  };

  const categorizedModels = categorizeModels(models || []);

  const fetchLibraryModels = async () => {
    setIsLoadingLibrary(true);
    setError("");
    try {
      const response = await fetch("http://127.0.0.1:5001/api/models/library");
      if (!response.ok)
        throw new Error(`Failed to fetch models: ${response.statusText}`);
      const data = await response.json();
      if (data.error) throw new Error(data.error);
      setLibraryModels(data.models || []);
    } catch (err) {
      console.error("Error fetching library models:", err);
      setError(err.message);
    } finally {
      setIsLoadingLibrary(false);
    }
  };

  const handleCreateModel = () => {
    if (!createModelName || !createModelFile) {
      alert("Please provide both model name and modelfile content");
      return;
    }
    onCreateModel(createModelName, createModelFile);
  };

  const handleCopyModel = () => {
    if (!copySourceModel || !copyDestinationModel) {
      alert("Please provide both source and destination model names");
      return;
    }
    onCopyModel(copySourceModel, copyDestinationModel);
  };

  const handlePushModel = () => {
    if (!pushModelName) {
      alert("Please provide a model name");
      return;
    }
    onPushModel(pushModelName);
  };

  const handleGenerateEmbeddings = () => {
    if (!embeddingModelName || !embeddingInput) {
      alert("Please provide both model name and input text");
      return;
    }
    onGenerateEmbeddings(embeddingModelName, embeddingInput);
  };

  useEffect(() => {
    if (isOpen && activeTab === "library") {
      fetchLibraryModels();
    }
  }, [isOpen, activeTab]);

  const filterModels = (modelsList) => {
    return modelsList.filter((model) => {
      const matchesSearch = model.name
        .toLowerCase()
        .includes(searchTerm.toLowerCase());
      const matchesType =
        modelTypeFilter === "all" || model.type === modelTypeFilter;
      return matchesSearch && matchesType;
    });
  };

  const filteredLibraryModels = filterModels(libraryModels);

  if (!isOpen) return null;

  return (
    <AnimatePresence>
      {isOpen && (
        <>
          <motion.div
            key="modal-backdrop"
            className="fixed inset-0 z-50 bg-background/80 backdrop-blur-sm"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          />
          <motion.div
            key="modal-wrapper"
            className="fixed inset-0 z-50 flex items-end justify-center"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          >
            <motion.div
              key="modal-content"
              className="relative w-full pointer-events-auto"
              drag="y"
              dragConstraints={{ top: 0 }}
              dragElastic={0.3}
              dragMomentum={false}
              onDragEnd={handleDragEnd}
              initial={{ y: window.innerHeight }}
              animate={{ y: 0 }}
              exit={{ y: window.innerHeight }}
              transition={{
                type: "spring",
                damping: 25,
                stiffness: 200,
                mass: 0.8,
              }}
            >
              <div className="bg-background border-t rounded-t-xl shadow-2xl max-h-[85vh] overflow-hidden">
                <div className="group flex justify-center py-2 cursor-grab active:cursor-grabbing">
                  <div className="w-12 h-1.5 bg-foreground/20 rounded-full transition-colors group-hover:bg-foreground/40" />
                </div>
                <div className="container max-w-6xl mx-auto pb-6 px-4">
                  <CardHeader className="flex items-center justify-between pb-3">
                    <div className="flex items-center gap-2">
                      <Bot className="h-5 w-5" />
                      <CardTitle>Model Management</CardTitle>
                    </div>
                    <div className="flex items-center gap-2">
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => setDetailedView(!detailedView)}
                        className="h-8 w-8"
                      >
                        <GripHorizontal className="h-4 w-4" />
                      </Button>
                      <Button variant="ghost" size="icon" onClick={onClose}>
                        <X className="h-4 w-4" />
                      </Button>
                    </div>
                  </CardHeader>
                  <CardContent>
                    <Tabs value={activeTab} onValueChange={setActiveTab}>
                      <TabsList className="grid w-full grid-cols-3 mb-4">
                        <TabsTrigger value="local">Local Models</TabsTrigger>
                        <TabsTrigger value="library">Model Library</TabsTrigger>
                        <TabsTrigger value="management">Management</TabsTrigger>
                      </TabsList>
                      <TabsContent value="local" className="mt-0">
                        <ScrollArea className="h-[calc(85vh-250px)]">
                          <div className="flex flex-col md:flex-row md:space-x-4">
                            {/* Text Models Section */}
                            <div className="flex-1 space-y-3">
                              <div className="flex items-center gap-2">
                                <Terminal className="h-4 w-4" />
                                <h3 className="text-sm font-medium">Text Models</h3>
                                <Badge variant="outline" className="ml-auto">
                                  {categorizedModels.text.length}
                                </Badge>
                              </div>
                              <div className="space-y-4">
                                {categorizedModels.text.map((model) => (
                                  <ModelCard
                                    key={model.name}
                                    model={model}
                                    modelType="text"
                                    detailedView={detailedView}
                                    onInfoClick={onModelClick}
                                    onDeleteClick={onDeleteModel}
                                    isRunning={runningModels.some(
                                      (m) => m.name === model.name
                                    )}
                                  />
                                ))}
                              </div>
                            </div>

                            {/* Vision Models Section */}
                            <div className="flex-1 space-y-3 mt-6 md:mt-0">
                              <div className="flex items-center gap-2">
                                <Eye className="h-4 w-4" />
                                <h3 className="text-sm font-medium">Vision Models</h3>
                                <Badge variant="outline" className="ml-auto">
                                  {categorizedModels.vision.length}
                                </Badge>
                              </div>
                              <div className="space-y-4">
                                {categorizedModels.vision.map((model) => (
                                  <ModelCard
                                    key={model.name}
                                    model={model}
                                    modelType="vision"
                                    detailedView={detailedView}
                                    onInfoClick={onModelClick}
                                    onDeleteClick={onDeleteModel}
                                    isRunning={runningModels.some(
                                      (m) => m.name === model.name
                                    )}
                                  />
                                ))}
                              </div>
                            </div>

                            {/* Embedding Models Section */}
                            <div className="flex-1 space-y-3 mt-6 md:mt-0">
                              <div className="flex items-center gap-2">
                                <Network className="h-4 w-4" />
                                <h3 className="text-sm font-medium">
                                  Embedding Models
                                </h3>
                                <Badge variant="outline" className="ml-auto">
                                  {categorizedModels.embeddings.length}
                                </Badge>
                              </div>
                              <div className="space-y-4">
                                {categorizedModels.embeddings.map((model) => (
                                  <ModelCard
                                    key={model.name}
                                    model={model}
                                    modelType="embedding"
                                    detailedView={detailedView}
                                    onInfoClick={onModelClick}
                                    onDeleteClick={onDeleteModel}
                                    isRunning={runningModels.some(
                                      (m) => m.name === model.name
                                    )}
                                  />
                                ))}
                              </div>
                            </div>
                          </div>
                        </ScrollArea>
                      </TabsContent>
                      <TabsContent value="library" className="mt-0">
                        <div className="space-y-6">
                          <div className="flex gap-4">
                            <div className="flex-1 relative">
                              <Input
                                placeholder="Search models..."
                                value={searchTerm}
                                onChange={(e) => setSearchTerm(e.target.value)}
                                className="w-full pl-10"
                              />
                              <Search className="h-4 w-4 absolute left-3 top-3 text-muted-foreground" />
                            </div>
                            <Select
                              value={modelTypeFilter}
                              onValueChange={setModelTypeFilter}
                            >
                              <SelectTrigger className="w-[180px]">
                                <SelectValue placeholder="Filter by type" />
                              </SelectTrigger>
                              <SelectContent>
                                <SelectItem value="all">All Types</SelectItem>
                                <SelectItem value="text">Text Models</SelectItem>
                                <SelectItem value="vision">Vision Models</SelectItem>
                                <SelectItem value="embedding">Embedding Models</SelectItem>
                              </SelectContent>
                            </Select>
                            <Button
                              variant="outline"
                              onClick={fetchLibraryModels}
                              disabled={isLoadingLibrary}
                            >
                              <RefreshCw
                                className={cn(
                                  "h-4 w-4 mr-2",
                                  isLoadingLibrary && "animate-spin"
                                )}
                              />
                              Refresh
                            </Button>
                          </div>

                          {error && (
                            <Alert variant="destructive">
                              <AlertCircle className="h-4 w-4" />
                              <AlertDescription>{error}</AlertDescription>
                            </Alert>
                          )}

                          <ScrollArea className="h-[calc(85vh-250px)]">
                            {isLoadingLibrary ? (
                              <div className="flex items-center justify-center h-40">
                                <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
                              </div>
                            ) : filteredLibraryModels.length > 0 ? (
                              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                {filteredLibraryModels.map((model) => (
                                  <ModelCard
                                    key={model.name}
                                    model={{
                                      ...model,
                                      size: "N/A",
                                      details: {
                                        parameter_size: "N/A",
                                        quantization_level: "N/A",
                                      },
                                    }}
                                    modelType={model.type}
                                    detailedView={true}
                                    onPullClick={() => onPullModel(model.name)}
                                    isLibraryModel={true}
                                  />
                                ))}
                              </div>
                            ) : (
                              <div className="flex flex-col items-center justify-center h-40 text-muted-foreground">
                                <p>No models found</p>
                                {searchTerm && (
                                  <p className="text-sm">
                                    Try adjusting your search criteria
                                  </p>
                                )}
                              </div>
                            )}
                          </ScrollArea>
                        </div>
                      </TabsContent>
                      <TabsContent value="management" className="mt-0">
                        <ScrollArea className="h-[calc(85vh-250px)]">
                          <div className="space-y-6">
                            {/* Pull Model Section */}
                            <div className="space-y-3">
                              <div className="flex items-center gap-2">
                                <RefreshCw className="h-4 w-4" />
                                <h3 className="text-sm font-medium">Pull a Model</h3>
                              </div>
                              <div className="flex items-center gap-2">
                                <Input
                                  placeholder="Model name (e.g., llama2)"
                                  value={pullModelName}
                                  onChange={(e) => setPullModelName(e.target.value)}
                                  className="flex-1"
                                />
                                <Button
                                  size="icon"
                                  onClick={() => onPullModel(pullModelName)}
                                  disabled={isPulling}
                                >
                                  {isPulling ? (
                                    <Loader2 className="h-4 w-4 animate-spin" />
                                  ) : (
                                    <RefreshCw className="h-4 w-4" />
                                  )}
                                </Button>
                              </div>
                              {pullStatus && (
                                <p className="text-sm text-muted-foreground">
                                  {pullStatus}
                                </p>
                              )}
                            </div>

                            {/* Create Model Section */}
                            <div className="space-y-3">
                              <div className="flex items-center gap-2">
                                <Plus className="h-4 w-4" />
                                <h3 className="text-sm font-medium">Create a Model</h3>
                              </div>
                              <div className="space-y-2">
                                <Input
                                  placeholder="Model name"
                                  value={createModelName}
                                  onChange={(e) => setCreateModelName(e.target.value)}
                                />
                                <Textarea
                                  placeholder="Modelfile content"
                                  value={createModelFile}
                                  onChange={(e) => setCreateModelFile(e.target.value)}
                                />
                                <Button onClick={handleCreateModel} disabled={isCreating}>
                                  {isCreating ? (
                                    <Loader2 className="h-4 w-4 animate-spin mr-2" />
                                  ) : null}
                                  Create Model
                                </Button>
                              </div>
                              {createStatus && (
                                <p className="text-sm text-muted-foreground">
                                  {createStatus}
                                </p>
                              )}
                            </div>

                            {/* Copy Model Section */}
                            <div className="space-y-3">
                              <div className="flex items-center gap-2">
                                <Copy className="h-4 w-4" />
                                <h3 className="text-sm font-medium">Copy a Model</h3>
                              </div>
                              <div className="space-y-2">
                                <Input
                                  placeholder="Source model"
                                  value={copySourceModel}
                                  onChange={(e) => setCopySourceModel(e.target.value)}
                                />
                                <Input
                                  placeholder="Destination model"
                                  value={copyDestinationModel}
                                  onChange={(e) => setCopyDestinationModel(e.target.value)}
                                />
                                <Button onClick={handleCopyModel} disabled={isCopying}>
                                  {isCopying ? (
                                    <Loader2 className="h-4 w-4 animate-spin mr-2" />
                                  ) : null}
                                  Copy Model
                                </Button>
                              </div>
                              {copyStatus && (
                                <p className="text-sm text-muted-foreground">
                                  {copyStatus}
                                </p>
                              )}
                            </div>

                            {/* Push Model Section */}
                            <div className="space-y-3">
                              <div className="flex items-center gap-2">
                                <Upload className="h-4 w-4" />
                                <h3 className="text-sm font-medium">Push a Model</h3>
                              </div>
                              <div className="flex items-center gap-2">
                                <Input
                                  placeholder="Model name (e.g., namespace/model:tag)"
                                  value={pushModelName}
                                  onChange={(e) => setPushModelName(e.target.value)}
                                  className="flex-1"
                                />
                                <Button onClick={handlePushModel} disabled={isPushing}>
                                  {isPushing ? (
                                    <Loader2 className="h-4 w-4 animate-spin mr-2" />
                                  ) : null}
                                  Push Model
                                </Button>
                              </div>
                              {pushStatus && (
                                <p className="text-sm text-muted-foreground">
                                  {pushStatus}
                                </p>
                              )}
                            </div>

                            {/* Generate Embeddings Section */}
                            <div className="space-y-3">
                              <div className="flex items-center gap-2">
                                <Cpu className="h-4 w-4" />
                                <h3 className="text-sm font-medium">
                                  Generate Embeddings
                                </h3>
                              </div>
                              <div className="space-y-2">
                                <Input
                                  placeholder="Embedding model name"
                                  value={embeddingModelName}
                                  onChange={(e) => setEmbeddingModelName(e.target.value)}
                                />
                                <Textarea
                                  placeholder="Input text"
                                  value={embeddingInput}
                                  onChange={(e) => setEmbeddingInput(e.target.value)}
                                />
                                <Button
                                  onClick={handleGenerateEmbeddings}
                                  disabled={isEmbedding}
                                >
                                  {isEmbedding ? (
                                    <Loader2 className="h-4 w-4 animate-spin mr-2" />
                                  ) : null}
                                  Generate Embeddings
                                </Button>
                              </div>
                              {embeddingStatus && (
                                <p className="text-sm text-muted-foreground">
                                  {embeddingStatus}
                                </p>
                              )}
                            </div>
                          </div>
                        </ScrollArea>

                      </TabsContent>
                    </Tabs>
                  </CardContent>
                </div>
              </div>
            </motion.div>
          </motion.div>
        </>
      )}
    </AnimatePresence>
  );
};

export default ModelsModal;


// ========================================
// File: simplified-ui/src/components/OnboardingTour.jsx
// ========================================

import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { X, ArrowRight, FileUp, Network, GitBranch, Bot, MessageCircle } from 'lucide-react';
import { Button } from './ui/button';

const TOUR_STEPS = [
  {
    id: 'welcome',
    title: 'Welcome to Tangent',
    content: 'Discover insights from your AI conversations with our interactive visualization and analysis tools.',
    icon: MessageCircle,
    highlight: 'center',
    position: 'center'
  },
  {
    id: 'upload',
    title: 'Upload Your Chats',
    content: 'Start by uploading your chat archive to visualize your conversation patterns and topics.',
    icon: FileUp,
    highlight: '[data-tour="upload"]',
    position: 'right'
  },
  {
    id: 'visualization',
    title: 'Interactive Visualization',
    content: 'Explore your conversation clusters in an interactive map. Similar topics are grouped together.',
    icon: Network,
    highlight: '[data-tour="visualization"]',
    position: 'bottom'
  },
  {
    id: 'branches',
    title: 'Conversation Branches',
    content: 'View and create conversation branches to explore different directions in your chats.',
    icon: GitBranch,
    highlight: '[data-tour="branches"]',
    position: 'left'
  },
  {
    id: 'models',
    title: 'AI Models',
    content: 'Switch between different AI models for your conversations and manage your model preferences.',
    icon: Bot,
    highlight: '[data-tour="models"]',
    position: 'bottom'
  }
];

const getTooltipPosition = (elementRect, position, tooltipSize = { width: 320, height: 200 }) => {
  if (position === 'center') {
    return {
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)'
    };
  }

  const spacing = 12; // Space between element and tooltip
  let top, left, transform;

  switch (position) {
    case 'top':
      top = elementRect.top - tooltipSize.height - spacing;
      left = elementRect.left + elementRect.width / 2;
      transform = 'translateX(-50%)';
      break;
    case 'bottom':
      top = elementRect.bottom + spacing;
      left = elementRect.left + elementRect.width / 2;
      transform = 'translateX(-50%)';
      break;
    case 'left':
      top = elementRect.top + elementRect.height / 2;
      left = elementRect.left - tooltipSize.width - spacing;
      transform = 'translateY(-50%)';
      break;
    case 'right':
      top = elementRect.top + elementRect.height / 2;
      left = elementRect.right + spacing;
      transform = 'translateY(-50%)';
      break;
    default:
      top = elementRect.bottom + spacing;
      left = elementRect.left;
      transform = 'translateX(0)';
  }

  // Adjust position if tooltip would go off screen
  const padding = 16;
  const viewport = {
    width: window.innerWidth - padding * 2,
    height: window.innerHeight - padding * 2
  };

  if (left < padding) {
    left = padding;
    transform = 'translateX(0)';
  } else if (left + tooltipSize.width > viewport.width) {
    left = viewport.width - tooltipSize.width;
    transform = 'translateX(0)';
  }

  if (top < padding) {
    top = padding;
  } else if (top + tooltipSize.height > viewport.height) {
    top = viewport.height - tooltipSize.height;
  }

  return { top, left, transform };
};

export default function OnboardingTour() {
  const [isActive, setIsActive] = useState(false);
  const [currentStep, setCurrentStep] = useState(0);
  const [tooltipPosition, setTooltipPosition] = useState({ top: 0, left: 0, transform: 'none' });
  const [highlightedElement, setHighlightedElement] = useState(null);

  useEffect(() => {
    const hasSeenTour = localStorage.getItem('hasSeenTour');
    if (!hasSeenTour) {
      setIsActive(true);
    }
  }, []);

  useEffect(() => {
    if (!isActive) return;

    const step = TOUR_STEPS[currentStep];
    if (step.highlight === 'center') {
      setHighlightedElement(null);
      setTooltipPosition(getTooltipPosition(null, 'center'));
    } else {
      const element = document.querySelector(step.highlight);
      if (element) {
        const rect = element.getBoundingClientRect();
        setHighlightedElement({
          top: rect.top,
          left: rect.left,
          width: rect.width,
          height: rect.height,
        });
        setTooltipPosition(getTooltipPosition(rect, step.position));
      }
    }
  }, [currentStep, isActive]);

  const handleComplete = () => {
    setIsActive(false);
    localStorage.setItem('hasSeenTour', 'true');
  };

  const handleNext = () => {
    if (currentStep < TOUR_STEPS.length - 1) {
      setCurrentStep(prev => prev + 1);
    } else {
      handleComplete();
    }
  };

  if (!isActive) return null;

  const currentTourStep = TOUR_STEPS[currentStep];
  const Icon = currentTourStep.icon;

  return (
    <div className="fixed inset-0 z-50 pointer-events-none">
      {/* Backdrop */}
      <div className="absolute inset-0 bg-background/80 backdrop-blur-sm" />

      {/* Highlight */}
      <AnimatePresence>
        {highlightedElement && (
          <motion.div
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.9 }}
            className="absolute border-2 border-primary rounded-lg"
            style={{
              top: highlightedElement.top - 4,
              left: highlightedElement.left - 4,
              width: highlightedElement.width + 8,
              height: highlightedElement.height + 8,
              boxShadow: '0 0 0 9999px rgba(0, 0, 0, 0.5)',
            }}
          />
        )}
      </AnimatePresence>

      {/* Tooltip */}
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        className="pointer-events-auto absolute w-[320px]"
        style={{
          top: tooltipPosition.top,
          left: tooltipPosition.left,
          transform: tooltipPosition.transform
        }}
      >
        <div className="relative rounded-xl border bg-card p-6 shadow-lg">
          <button
            onClick={handleComplete}
            className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2"
          >
            <X className="h-4 w-4" />
          </button>

          <div className="space-y-4">
            <div className="flex items-center gap-3">
              <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-primary/10">
                <Icon className="h-5 w-5 text-primary" />
              </div>
              <h2 className="font-semibold tracking-tight">{currentTourStep.title}</h2>
            </div>

            <p className="text-sm text-muted-foreground leading-relaxed">
              {currentTourStep.content}
            </p>

            <div className="flex items-center justify-between pt-4">
              <div className="flex gap-1">
                {TOUR_STEPS.map((_, index) => (
                  <div
                    key={index}
                    className={`h-1.5 w-4 rounded-full transition-colors ${
                      index === currentStep ? 'bg-primary' : 'bg-muted'
                    }`}
                  />
                ))}
              </div>

              <div className="flex gap-2">
                <Button variant="outline" size="sm" onClick={handleComplete}>
                  Skip
                </Button>
                <Button size="sm" onClick={handleNext}>
                  {currentStep === TOUR_STEPS.length - 1 ? (
                    'Get started'
                  ) : (
                    <>
                      Next
                      <ArrowRight className="ml-2 h-4 w-4" />
                    </>
                  )}
                </Button>
              </div>
            </div>
          </div>
        </div>
      </motion.div>
    </div>
  );
}


// ========================================
// File: simplified-ui/src/components/RecordingButton.jsx
// ========================================

import React, { useRef, useState, useEffect } from 'react';
import { Mic, MicOff, Loader2 } from 'lucide-react';

export const RecordingButton = ({ 
  onTranscriptionComplete, 
  onRecordingStart,
  onRecordingStop,
  variant = 'default', 
  className = '' 
}) => {
  const [isRecording, setIsRecording] = useState(false);
  const [error, setError] = useState(null);
  const [tempTranscript, setTempTranscript] = useState('');
  const mediaRecorderRef = useRef(null);
  const audioContextRef = useRef(null);
  const streamRef = useRef(null);
  const audioChunksRef = useRef([]);

  useEffect(() => {
    return () => {
      if (streamRef.current) {
        streamRef.current.getTracks().forEach(track => track.stop());
      }
      if (audioContextRef.current?.state !== 'closed') {
        audioContextRef.current?.close();
      }
    };
  }, []);

  const startRecording = async () => {
    try {
      setError(null);
      audioChunksRef.current = [];
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      streamRef.current = stream;
      
      audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
      mediaRecorderRef.current = new MediaRecorder(stream);

      mediaRecorderRef.current.addEventListener('dataavailable', (event) => {
        if (event.data.size > 0) {
          audioChunksRef.current.push(event.data);
        }
      });

      mediaRecorderRef.current.addEventListener('stop', async () => {
        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
        await sendToWhisperServer(audioBlob);
      });

      mediaRecorderRef.current.start(1000);
      setIsRecording(true);
      setTempTranscript('');
      onRecordingStart?.();
    } catch (error) {
      console.error('Recording error:', error);
      setError(error.name === 'NotAllowedError' 
        ? 'Please allow microphone access to record audio.'
        : 'Failed to start recording: ' + error.message
      );
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current?.state === 'recording') {
      mediaRecorderRef.current.stop();
      streamRef.current?.getTracks().forEach(track => track.stop());
      streamRef.current = null;
      setIsRecording(false);
      onRecordingStop?.();
    }
  };

  async function audioBufferToWav(buffer, sampleRate = 16000) {
    const offlineContext = new OfflineAudioContext(
      buffer.numberOfChannels,
      buffer.duration * sampleRate,
      sampleRate
    );

    const source = offlineContext.createBufferSource();
    source.buffer = buffer;
    source.connect(offlineContext.destination);
    source.start(0);

    const resampledBuffer = await offlineContext.startRendering();
    return bufferToWave(resampledBuffer, resampledBuffer.length);
  }

  function bufferToWave(abuffer, len) {
    let numOfChan = abuffer.numberOfChannels,
        length = len * numOfChan * 2 + 44,
        buffer = new ArrayBuffer(length),
        view = new DataView(buffer),
        channels = [],
        pos = 0;

    // Write WAV header
    setUint32(0x46464952); // "RIFF"
    setUint32(length - 8); // file length - 8
    setUint32(0x45564157); // "WAVE"
    setUint32(0x20746d66); // "fmt " chunk
    setUint32(16); // length = 16
    setUint16(1); // PCM (uncompressed)
    setUint16(numOfChan);
    setUint32(abuffer.sampleRate);
    setUint32(abuffer.sampleRate * numOfChan * 2); // avg. bytes/sec
    setUint16(numOfChan * 2); // block-align
    setUint16(16); // 16-bit (hardcoded)

    setUint32(0x61746164); // "data" - chunk
    setUint32(length - pos - 4); // chunk length

    // Write interleaved data
    for (let i = 0; i < numOfChan; i++) {
      channels.push(abuffer.getChannelData(i));
    }

    let offset = 0;
    while (pos < length) {
      for (let i = 0; i < numOfChan; i++) {
        let sample = Math.max(-1, Math.min(1, channels[i][offset])); // Clamp
        sample = sample < 0 ? sample * 0x8000 : sample * 0x7fff; // Convert to 16-bit
        view.setInt16(pos, sample, true); // Write 16-bit sample
        pos += 2;
      }
      offset++; // Next source sample
    }

    // Helper functions to write data
    function setUint16(data) {
      view.setUint16(pos, data, true);
      pos += 2;
    }

    function setUint32(data) {
      view.setUint32(pos, data, true);
      pos += 4;
    }

    return new Blob([buffer], { type: 'audio/wav' });
  }

  const sendToWhisperServer = async (audioBlob) => {
    try {
      console.log('Processing audio...');
      
      // Decode the WebM audio data
      const arrayBuffer = await audioBlob.arrayBuffer();
      const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);

      // Resample and encode the audio data as WAV at 16 kHz
      console.log('Converting to WAV...');
      const wavBlob = await audioBufferToWav(audioBuffer, 16000);
      console.log('WAV blob size:', wavBlob.size, 'bytes');

      const formData = new FormData();
      formData.append('file', wavBlob, 'recording.wav');
      formData.append('temperature', '0.0');

      console.log('Sending request to Whisper server...');
      const response = await fetch('http://127.0.0.1:8080/inference', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`Transcription failed: ${response.statusText}`);
      }

      const data = await response.json();
      console.log('Whisper response:', data);

      if (data.text?.trim()) {
        setTempTranscript(data.text);
        onTranscriptionComplete?.(data.text);
      } else {
        throw new Error('No transcription text received');
      }
    } catch (error) {
      console.error('Transcription error:', error);
      setError('Transcription failed: ' + error.message);
    }
  };

  const buttonStyles = {
    default: `p-3 rounded-xl transition-all duration-300 ${
      isRecording 
        ? 'bg-red-500 hover:bg-red-600 animate-pulse' 
        : 'bg-blue-500 hover:bg-blue-600'
    }`,
    branch: `p-2 rounded-full hover:bg-gray-100 transition-colors ${
      isRecording ? 'text-red-500 animate-pulse' : ''
    }`
  };

  return (
    <div className="relative">
      <button
        onClick={isRecording ? stopRecording : startRecording}
        disabled={!!error}
        className={`${buttonStyles[variant]} ${className}`}
        aria-label={isRecording ? 'Stop recording' : 'Start recording'}
      >
        {isRecording ? (
          <MicOff className={`h-5 w-5 ${variant === 'default' ? 'text-white' : ''}`} />
        ) : (
          <Mic className={`h-5 w-5 ${variant === 'default' ? 'text-white' : ''}`} />
        )}
      </button>
      
      {error && (
        <Alert variant="destructive" className="mt-2 absolute bottom-full mb-2 w-64">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      
      {isRecording && tempTranscript && variant === 'default' && (
        <div className="mt-2 text-sm text-gray-600 animate-pulse">
          {tempTranscript}
        </div>
      )}
    </div>
  );
};

const Alert = ({ children, variant = "default", className = "" }) => {
  const baseStyles = "relative w-full rounded-lg border px-4 py-3 text-sm";
  const variantStyles = {
    default: "bg-white text-gray-950 border-gray-200",
    destructive: "border-red-500/50 text-red-600 bg-red-50",
    warning: "border-yellow-500/50 text-yellow-700 bg-yellow-50/50",
    info: "border-blue-500/50 text-blue-700 bg-blue-50/50",
    success: "border-green-500/50 text-green-700 bg-green-50/50"
  };

  return (
    <div role="alert" className={`${baseStyles} ${variantStyles[variant]} ${className}`}>
      {children}
    </div>
  );
};

const AlertDescription = ({ children, className = "" }) => (
  <div className={`text-sm [&_p]:leading-relaxed ${className}`}>
    {children}
  </div>
);




// ========================================
// File: simplified-ui/src/components/ReflectionDialog.jsx
// ========================================

import ReactMarkdown from "react-markdown";
import React, {
    useEffect,
    useState,
} from "react";
import {
    Lightbulb,
    Loader2,
    ScrollText,
    MessageCircle,
} from "lucide-react";
import {
    Button,
    DialogFooter,
    Dialog,
    DialogContent,
    DialogHeader,
    DialogTitle,
    ScrollArea,
} from "./index";
import { cn } from "./lib/utils";
import { Tabs, TabsContent, TabsTrigger, TabsList } from './ui/tabs'




const ReflectionDialog = ({ open, onOpenChange, conversation, reflection }) => {
    const [activeTab, setActiveTab] = useState(
        reflection ? "reflection" : "conversation"
    );

    const formatDate = (dateString) => {
        try {
            return new Date(dateString).toLocaleString();
        } catch (e) {
            return dateString;
        }
    };

    // Update activeTab when reflection availability changes
    useEffect(() => {
        if (!reflection && activeTab === "reflection") {
            setActiveTab("conversation");
        }
    }, [reflection, activeTab]);

    return (
        <Dialog open={open} onOpenChange={onOpenChange}>
            <DialogContent className="sm:max-w-[700px] max-h-[80vh] overflow-hidden flex flex-col">
                <DialogHeader>
                    <DialogTitle className="flex items-center gap-2 text-xl">
                        <Lightbulb className="h-5 w-5 text-amber-500" />
                        {conversation?.title || "Conversation"}
                    </DialogTitle>
                </DialogHeader>

                {/* Make sure the value prop matches the activeTab state */}
                <Tabs
                    value={activeTab}
                    onValueChange={setActiveTab}
                    className="flex-1 overflow-hidden"
                >
                    <div className="flex items-center justify-between">
                        <TabsList>
                            <TabsTrigger value="conversation" className="gap-2">
                                <MessageCircle className="h-4 w-4" />
                                Conversation
                            </TabsTrigger>
                            {reflection && (
                                <TabsTrigger value="reflection" className="gap-2">
                                    <ScrollText className="h-4 w-4" />
                                    Reflection
                                </TabsTrigger>
                            )}
                        </TabsList>
                        {/* Add timestamp if available */}
                        {conversation?.messages?.[0]?.timestamp && (
                            <span className="text-xs text-muted-foreground px-4">
                                {formatDate(conversation.messages[0].timestamp)}
                            </span>
                        )}
                    </div>

                    {/* Conversation Tab Content */}
                    <TabsContent
                        value="conversation"
                        className="flex-1 overflow-hidden mt-4"
                    >
                        <ScrollArea className="h-[500px] pr-4">
                            {conversation?.messages ? (
                                <div className="space-y-4">
                                    {conversation.messages.map((message, index) => (
                                        <div
                                            key={index}
                                            className={cn(
                                                "flex flex-col gap-2 rounded-lg p-4",
                                                message.sender === "human"
                                                    ? "bg-muted/50"
                                                    : "bg-primary/5 border border-primary/10"
                                            )}
                                        >
                                            <div className="flex items-center gap-2">
                                                <span
                                                    className={cn(
                                                        "text-xs font-medium",
                                                        message.sender === "human"
                                                            ? "text-muted-foreground"
                                                            : "text-primary"
                                                    )}
                                                >
                                                    {message.sender === "human" ? "You" : "Assistant"}
                                                </span>
                                                <span className="text-xs text-muted-foreground">
                                                    {formatDate(message.timestamp)}
                                                </span>
                                            </div>
                                            <div className="text-sm leading-relaxed whitespace-pre-wrap">
                                                {message.text}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            ) : (
                                <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
                                    <Loader2 className="h-8 w-8 animate-spin mb-4" />
                                    <p>Loading conversation...</p>
                                </div>
                            )}
                        </ScrollArea>
                    </TabsContent>

                    {/* Reflection Tab Content */}
                    {reflection && (
                        <TabsContent
                            value="reflection"
                            className="flex-1 overflow-hidden mt-4"
                        >
                            <ScrollArea className="h-[500px] pr-4">
                                <div className="prose prose-sm dark:prose-invert">
                                    <div className="bg-muted/50 rounded-lg p-6 border border-muted-foreground/20">
                                        <ReactMarkdown
                                            components={{
                                                h1: ({ children }) => (
                                                    <h1 className="text-xl font-bold mt-4 mb-2">
                                                        {children}
                                                    </h1>
                                                ),
                                                h2: ({ children }) => (
                                                    <h2 className="text-lg font-bold mt-3 mb-2">
                                                        {children}
                                                    </h2>
                                                ),
                                                h3: ({ children }) => (
                                                    <h3 className="text-base font-bold mt-2 mb-1">
                                                        {children}
                                                    </h3>
                                                ),
                                                p: ({ children }) => (
                                                    <p className="mb-4 leading-relaxed">{children}</p>
                                                ),
                                                ul: ({ children }) => (
                                                    <ul className="list-disc pl-4 mb-4">{children}</ul>
                                                ),
                                                ol: ({ children }) => (
                                                    <ol className="list-decimal pl-4 mb-4">{children}</ol>
                                                ),
                                                li: ({ children }) => (
                                                    <li className="mb-1">{children}</li>
                                                ),
                                                code: ({ children }) => (
                                                    <code className="bg-muted px-1.5 py-0.5 rounded-md text-sm">
                                                        {children}
                                                    </code>
                                                ),
                                                pre: ({ children }) => (
                                                    <pre className="bg-muted p-4 rounded-lg overflow-x-auto mb-4">
                                                        {children}
                                                    </pre>
                                                ),
                                            }}
                                        >
                                            {reflection}
                                        </ReactMarkdown>
                                    </div>
                                </div>
                            </ScrollArea>
                        </TabsContent>
                    )}
                </Tabs>

                <div className="pt-4 border-t">
                    <DialogFooter>
                        <Button variant="outline" onClick={() => onOpenChange(false)}>
                            Close
                        </Button>
                    </DialogFooter>
                </div>
            </DialogContent>
        </Dialog>
    );
};


export default ReflectionDialog;


// ========================================
// File: simplified-ui/src/components/TangentChat.jsx
// ========================================

import React, { useState, useRef, useEffect, useCallback } from 'react';
import { BranchNode } from './BranchNode';
import ChatInterface from './ChatInterface';
import CanvasToolbar from './CanvasToolbar';
import ChatContainer from './ChatContainer';
import FloatingInput from './FloatingInput';
import { MessageNavigator } from './MessageNavigator'
import { ModelStatus } from './ModelStatus'
import { cn } from "./lib/utils";
import { useVisualization } from './VisualizationProvider';

export function GridBackground({ translate, scale, className }) {
  const gridSize = 20;
  const viewWidth = window.innerWidth;
  const viewHeight = window.innerHeight;
  const offsetX = (translate.x % (gridSize * scale)) / scale;
  const offsetY = (translate.y % (gridSize * scale)) / scale;

  return (
    <svg
      className="absolute inset-0 w-full h-full pointer-events-none"
      style={{
        transform: `translate(${offsetX}px, ${offsetY}px)`,
      }}
    >
      <defs>
        <pattern
          id="grid"
          width={gridSize}
          height={gridSize}
          patternUnits="userSpaceOnUse"
        >
          <path
            d="M 20 0 L 0 0 0 20"
            fill="none"
            className={cn("stroke-[1.2]", className)}
          />
        </pattern>
      </defs>
      <rect
        x="-20"
        y="-20"
        width={viewWidth + 40}
        height={viewHeight + 40}
        fill="url(#grid)"
      />
    </svg>
  );
}

const defaultTemplate = {
  id: 'template',
  type: 'template',
  title: 'New Branch',
  systemPrompt: '',
  x: 50,
  y: 150,
  messages: []
};

const systemPrompt = `You are a helpful AI assistant. When responding:
1. For brief responses ("briefly", "quick", "short"):
   - Use maximum 3 sentences
   - Focus on core concepts only

2. For comprehensive responses ("tell me everything", "explain in detail"):
   - Write at least 6-8 paragraphs
   - Cover fundamentals, history, types, applications
   - Include specific examples and use cases
   - Explain technical concepts in depth
   - Break down complex topics into subtopics
   - Discuss current trends and future implications

3. For unspecified length:
   - Provide 4-5 sentences
   - Balance detail and brevity

4. Always adapt your response length based on explicit or implicit length cues in the user's question`;


const TangentChat = ({
  initialConversation,
  isPanelCollapsed = false,
  nodes,
  setNodes,
  activeChat,
  setActiveChat
}) => {
  const [selectedNodePosition, setSelectedNodePosition] = useState(null);

  const [temperature, setTemperature] = useState(0.7);

  const { handleRefresh, theme, setTheme } = useVisualization();


  const [containerWidth, setContainerWidth] = useState(400);

  const [expandedMessages, setExpandedMessages] = useState(new Set());

  const [selectedNode, setSelectedNode] = useState(initialConversation?.id || 1);
  const [focusedMessageIndex, setFocusedMessageIndex] = useState(0);
  const [expandedNodes, setExpandedNodes] = useState(new Set([initialConversation?.id]));
  const [inputValue, setInputValue] = useState(''); // Changed from input to inputValue
  const [activeTool, setActiveTool] = useState('pan');
  const [scale, setScale] = useState(1);
  const [translate, setTranslate] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [lastMousePos, setLastMousePos] = useState({ x: 0, y: 0 });
  const [isLoading, setIsLoading] = useState(false);
  const [models, setModels] = useState([]);
  const [isModelDropdownOpen, setIsModelDropdownOpen] = useState(false);
  const modelDropdownRef = useRef(null);
  const [selectedModel, setSelectedModel] = useState('');
  const [chatContainerSize, setChatContainerSize] = useState('normal');
  const [activeContext, setActiveContext] = useState({
    messages: [],
    systemPrompt: '',
    parentChain: []
  });
  const [dragState, setDragState] = useState({
    isDragging: false,
    nodeId: null,
    startPos: { x: 0, y: 0 },
    nodeStartPos: { x: 0, y: 0 }
  });
  const [streamingMessage, setStreamingMessage] = useState("");
  const [continuationCount, setContinuationCount] = useState(0);
  const lastResponseTime = useRef(null);

  const [showQuickInput, setShowQuickInput] = useState(true);
  const [quickInputPosition, setQuickInputPosition] = useState({
    x: window.innerWidth / 2 - 192, // Half of input width (384/2)
    y: window.innerHeight - 90
  });

  const [contentHeight, setContentHeight] = useState(0);

  const canvasRef = useRef(null);
  const nodesRef = useRef(nodes);
  const transformRef = useRef({ scale, translate });

  const contentRef = useRef(null);


  nodesRef.current = nodes;


  // Add a sensitivity factor for panning
  const PANNING_SENSITIVITY = 0.42;
  // Add a sensitivity factor for dragging nodes

  const ZOOM_SENSITIVITY = 0.0012;

  const getChatContainerWidth = useCallback(() => {
    const widths = {
      collapsed: 240,
      normal: 400,
      large: 1200,
      xlarge: Math.floor(window.innerWidth * 0.73)
    };
    return widths[chatContainerSize] || widths.normal;
  }, [chatContainerSize]);


  const getFullMessageHistory = useCallback((nodeId) => {
    const currentNode = nodes.find(n => n.id === nodeId);
    if (!currentNode) return [];

    // If it's the main thread or has no parent, return messages as is
    if (currentNode.type === 'main' || !currentNode.parentId) {
      return currentNode.messages;
    }

    // For branch nodes, return the contextMessages if they exist
    if (currentNode.contextMessages) {
      return currentNode.contextMessages;
    }

    // Fallback to just the node's messages if no context exists
    return currentNode.messages;
  }, [nodes]);


  useEffect(() => {
    transformRef.current = { scale, translate };
  }, [scale, translate]);


  useEffect(() => {
    if (!contentRef.current) return;

    const height = contentRef.current.getBoundingClientRect().height;
    setContentHeight(height);

    // Only pan if content exceeds viewport
    if (height > window.innerHeight) {
      const overflow = height - window.innerHeight;
      setTranslate(prev => ({
        ...prev,
        y: -overflow + 200 // Leave some space at bottom
      }));
    }
  }, [nodes]); // Run when messages/nodes update


  useEffect(() => {
    const root = document.documentElement;
    // Remove all possible theme classes
    root.classList.remove('light', 'dark', 'hextech-nordic', 'singed-theme');
    // Add the selected theme
    root.classList.add(theme);
    localStorage.setItem('theme', theme);
  }, [theme]);

  useEffect(() => {
    if (initialConversation && Array.isArray(initialConversation)) {
      const updatedNodes = initialConversation.map((node) => ({
        ...node,
        x: node.x ?? selectedNodePosition?.x ?? 400,
        y: node.y ?? selectedNodePosition?.y ?? 100,
      }));
      setNodes(updatedNodes);
      setExpandedNodes(new Set(updatedNodes.map((node) => node.id)));
      setSelectedNode(updatedNodes[0]?.id || 1);
    }
  }, [initialConversation, selectedNodePosition]);

  // Fetch available models
  useEffect(() => {
    const fetchModels = async () => {
      try {
        const response = await fetch('http://localhost:11434/api/tags');
        const data = await response.json();
        setModels(data.models);
        if (data.models.length > 0) {
          setSelectedModel(data.models[0].name);
        }
      } catch (error) {
        console.error('Error fetching models:', error);
      }
    };
    fetchModels();
  }, []);

  const handleToggleMessageExpand = useCallback((messageIndex) => {
    setExpandedMessages(prev => {
      const next = new Set(prev);
      if (next.has(messageIndex)) {
        next.delete(messageIndex);
      } else {
        next.add(messageIndex);
      }
      return next;
    });
  }, []);



  const handleToolSelect = useCallback((tool) => {
    setActiveTool(tool);
  }, []);

  const handleThemeChange = useCallback((newTheme) => {
    setTheme(newTheme);
  }, []);

  const focusOnMessage = useCallback((nodeId, messageIndex, zoomInClose = false) => {
    const node = nodes.find(n => n.id === nodeId);
    if (!node) return;

    const canvasRect = canvasRef.current?.getBoundingClientRect();
    if (!canvasRect) return;

    // Calculate message position within node
    const messageOffset = messageIndex * 120; // Approximate height per message
    const messageY = node.y + 300 + messageOffset; // 100px is base node header height

    // Center the canvas on the message
    const centerX = canvasRect.width / 2;
    const centerY = canvasRect.height / 2;

    // Calculate new translation to center the message
    const newTranslateX = centerX - (node.x + 128) * scale;
    const newTranslateY = centerY - messageY * scale;

    // Update translation
    setTranslate({
      x: newTranslateX,
      y: newTranslateY
    });

    // Set zoom level based on whether Shift is pressed
    setScale(zoomInClose ? 2 : scale);

    // Expand the node if it's not already expanded
    if (!expandedNodes.has(nodeId)) {
      setExpandedNodes(prev => new Set([...prev, nodeId]));
    }

    // Select the node
    setSelectedNode(nodeId);
    setFocusedMessageIndex(messageIndex);
  }, [nodes, scale, expandedNodes]);


  const handleInputChange = (e) => {
    // If it's an event, use e.target.value, otherwise use the value directly
    const newValue = e.target ? e.target.value : e;
    setInputValue(newValue);
  };

  const handleSendMessage = async () => {
    if (!inputValue.trim() || !selectedNode) return;

    const currentNode = nodes.find(n => n.id === selectedNode);
    if (!currentNode) return;

    setIsLoading(true);
    const newMessage = { role: 'user', content: inputValue };

    // Create initial messages arrays including the new user message
    const visibleMessages = [...currentNode.messages, newMessage];
    const contextMessages = currentNode.type === 'branch'
      ? [...(currentNode.contextMessages || []), newMessage]
      : null;

    // Update node with user message immediately
    setNodes(prevNodes => prevNodes.map(node =>
      node.id === selectedNode
        ? {
          ...node,
          messages: visibleMessages,
          contextMessages: currentNode.type === 'branch' ? contextMessages : undefined
        }
        : node
    ));

    setInputValue('');
    setStreamingMessage("");
    setContinuationCount(0);
    lastResponseTime.current = Date.now();

    try {
      const conversationContext = currentNode.type === 'branch'
        ? contextMessages
        : visibleMessages;

      const conversationHistory = conversationContext
        .map(msg => `${msg.role === 'user' ? 'Human' : 'Assistant'}: ${msg.content}`)
        .join('\n');

      const requestBody = {
        model: selectedModel,
        prompt: `${conversationHistory}\n\nHuman: ${inputValue}\n\nAssistant:`,
        system: currentNode.systemPrompt || systemPrompt,
        stream: true,
        options: {
          temperature: temperature, // Use the temperature state here
          num_ctx: 8192,
          top_p: 0.9,
          top_k: 20,
          typical_p: 0.7,
          mirostat: 1,
          mirostat_tau: 0.8,
          mirostat_eta: 0.6,
        }
      };

      const response = await fetch('http://localhost:11434/api/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);
      }

      let accumulatedResponse = '';
      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      const updateStreamingContent = (content) => {
        setStreamingMessage(content);

        // Only update the node's streamingContent field
        setNodes(prevNodes => prevNodes.map(node => {
          if (node.id !== selectedNode) return node;

          return {
            ...node,
            streamingContent: content
          };
        }));
      };

      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value);
          const lines = chunk.split('\n');

          for (const line of lines) {
            if (!line.trim()) continue;

            try {
              const data = JSON.parse(line);

              if (data.error) {
                console.error('Server returned error:', data.error);
                continue;
              }

              if (data.response !== undefined) {
                accumulatedResponse += data.response;
                updateStreamingContent(accumulatedResponse);

                const now = Date.now();
                if (lastResponseTime.current && (now - lastResponseTime.current) > 500) {
                  setContinuationCount(prev => prev + 1);
                }
                lastResponseTime.current = now;
              }
            } catch (e) {
              console.error('Error parsing JSON line:', e);
            }
          }
        }
      } finally {
        // Add the final complete message only once
        setNodes(prevNodes => prevNodes.map(node => {
          if (node.id !== selectedNode) return node;

          const finalMessage = {
            role: 'assistant',
            content: accumulatedResponse,
            continuationCount
          };

          // Get messages without any streaming message
          const baseMessages = node.messages.filter(msg => !msg.isStreaming);
          const baseContextMessages = node.type === 'branch'
            ? node.contextMessages?.filter(msg => !msg.isStreaming)
            : null;

          return {
            ...node,
            messages: [...baseMessages, finalMessage],
            contextMessages: node.type === 'branch'
              ? [...baseContextMessages, finalMessage]
              : undefined,
            streamingContent: null // Clear streaming content
          };
        }));

        setStreamingMessage(""); // Clear streaming message
        reader.releaseLock();
      }
    } catch (error) {
      console.error('Error in handleSendMessage:', error);
      setStreamingMessage("");

      // Update nodes to remove streaming state
      setNodes(prevNodes => prevNodes.map(node => ({
        ...node,
        streamingContent: null
      })));
    } finally {
      setIsLoading(false);
    }
  };

  const handleUpdateTitle = (nodeId, newTitle) => {
    setNodes(prevNodes => prevNodes.map(node =>
      node.id === nodeId ? { ...node, title: newTitle } : node
    ));
  };

  const buildConversationContext = (node) => {
    let context = {
      messages: [],
      parentChain: []
    };

    // Build the chain of parent nodes
    let currentNode = node;
    while (currentNode) {
      context.parentChain.unshift(currentNode.id);
      if (currentNode.parentId) {
        const parentNode = nodes.find(n => n.id === currentNode.parentId);
        if (parentNode) {
          // Add messages up to the branch point
          const relevantMessages = parentNode.messages.slice(0, currentNode.parentMessageIndex + 1);
          context.messages.unshift(...relevantMessages);
          currentNode = parentNode;
        } else {
          break;
        }
      } else {
        break;
      }
    }

    // Add the current node's messages
    context.messages.push(...node.messages);

    return context;
  };

  const handleCreateBranch = async (parentNodeId, messageIndex, position = null) => {
    const parentNode = nodes.find(n => n.id === parentNodeId);
    if (!parentNode) return;

    // Calculate position using the new function instead of using provided position
    const branchPosition = calculateBranchPosition(parentNode, messageIndex, nodes);

    const newNode = createBranch(
      parentNode,
      defaultTemplate,
      nodes,
      messageIndex,
      branchPosition // Use calculated position
    );

    // Update the active context with the full context from parent
    const branchContext = buildConversationContext(newNode);
    setActiveContext(branchContext);

    setNodes(prevNodes => [...prevNodes, newNode]);
    setSelectedNode(newNode.id);
  };


  const screenToCanvas = useCallback((screenX, screenY) => {
    const { scale, translate } = transformRef.current;
    return {
      x: (screenX - translate.x) / scale,
      y: (screenY - translate.y) / scale
    };
  }, []);

  const handleDragStart = useCallback((e, node) => {
    if (node.type === 'main') return;

    e.preventDefault();
    e.stopPropagation();

    const canvasPos = screenToCanvas(e.clientX, e.clientY);

    setDragState({
      isDragging: true,
      nodeId: node.id,
      startPos: canvasPos,
      nodeStartPos: { x: node.x, y: node.y }
    });
  }, [screenToCanvas]);

  const handleDrag = useCallback((e) => {
    if (!dragState.isDragging) return;

    const currentPos = screenToCanvas(e.clientX, e.clientY);

    const deltaX = currentPos.x - dragState.startPos.x;
    const deltaY = currentPos.y - dragState.startPos.y;

    setNodes(prevNodes =>
      prevNodes.map(node =>
        node.id === dragState.nodeId
          ? {
            ...node,
            x: dragState.nodeStartPos.x + deltaX,
            y: dragState.nodeStartPos.y + deltaY
          }
          : node
      )
    );
  }, [dragState, screenToCanvas]);

  const handleDragEnd = useCallback(() => {
    setDragState({
      isDragging: false,
      nodeId: null,
      startPos: { x: 0, y: 0 },
      nodeStartPos: { x: 0, y: 0 }
    });
  }, []);

  const getSiblingBranches = useCallback((nodeId) => {
    const currentNode = nodes.find(n => n.id === nodeId);
    if (!currentNode || !currentNode.parentId) return [];

    // Get all branches that share the same parent and parent message index
    return nodes.filter(n =>
      n.id !== nodeId &&
      n.parentId === currentNode.parentId &&
      n.parentMessageIndex === currentNode.parentMessageIndex
    ).sort((a, b) => a.y - b.y); // Sort by vertical position
  }, [nodes]);

  // Handle canvas mouse down for both panning and node dragging
  const handleCanvasMouseDown = useCallback((e) => {
    if (e.button !== 0) return;

    const target = e.target;
    const isBackground = target === canvasRef.current ||
      target.classList.contains('grid-background');

    if (activeTool === 'pan' || (activeTool === 'select' && (e.ctrlKey || e.metaKey || isBackground))) {
      e.preventDefault();
      setIsPanning(true);
      setLastMousePos({ x: e.clientX, y: e.clientY });
    }
  }, [activeTool]);

  const handleDeleteNode = (nodeId) => {
    // Also delete all child nodes
    const nodesToDelete = new Set([nodeId]);
    let foundMore = true;

    while (foundMore) {
      foundMore = false;
      nodes.forEach(node => {
        if (node.parentId && nodesToDelete.has(node.parentId) && !nodesToDelete.has(node.id)) {
          nodesToDelete.add(node.id);
          foundMore = true;
        }
      });
    }

    setNodes(nodes.filter(node => !nodesToDelete.has(node.id)));
    if (selectedNode && nodesToDelete.has(selectedNode)) {
      setSelectedNode(1); // Return to main thread
    }
  };


  const handleWheel = useCallback((e) => {
    e.preventDefault();

    const { scale: currentScale, translate: currentTranslate } = transformRef.current;
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Check if it's a zoom gesture (CMD/CTRL pressed)
    if (e.ctrlKey || e.metaKey) {
      // Handle zooming
      const delta = -e.deltaY * ZOOM_SENSITIVITY;
      const zoom = Math.exp(delta);

      // Limit scale between 0.1 and 5 with smoother transitions
      const newScale = Math.min(Math.max(0.1, currentScale * zoom), 5);

      const mouseBeforeZoom = screenToCanvas(mouseX, mouseY);
      const scaleDiff = newScale - currentScale;

      const newTranslate = {
        x: currentTranslate.x - mouseBeforeZoom.x * scaleDiff,
        y: currentTranslate.y - mouseBeforeZoom.y * scaleDiff
      };

      setScale(newScale);
      setTranslate(newTranslate);
    } else {
      // Handle panning (two-finger gesture or trackpad)
      // Apply panning sensitivity for smoother movement
      const dx = e.deltaX * PANNING_SENSITIVITY;
      const dy = e.deltaY * PANNING_SENSITIVITY;

      setTranslate(prev => ({
        x: prev.x - dx,
        y: prev.y - dy
      }));
    }
  }, [screenToCanvas]);

  const calculateBranchPosition = (parentNode, messageIndex, existingNodes) => {
    const BASE_SPACING_X = 300; // Horizontal space between branches
    const BASE_SPACING_Y = 120; // Vertical space between sibling branches
    const MESSAGE_HEIGHT = 120; // Height per message

    // Calculate base position relative to parent message
    const baseX = parentNode.x + BASE_SPACING_X;
    const baseY = parentNode.y + (messageIndex * MESSAGE_HEIGHT);

    // Get existing branches at this message index
    const siblingBranches = existingNodes.filter(node =>
      node.parentId === parentNode.id &&
      node.parentMessageIndex === messageIndex
    );

    // Stack new branch below existing siblings
    const verticalOffset = siblingBranches.length * BASE_SPACING_Y;

    return {
      x: baseX,
      y: baseY + verticalOffset
    };
  };

  // Function to center the main node
  const centerCanvas = useCallback(() => {
    if (!canvasRef.current) return;

    // Calculate expanded bounds including messages
    const calculateExpandedBounds = (nodes, expandedNodes) => {
      return nodes.reduce((bounds, node) => {
        const nodeWidth = NODE_WIDTH;
        let nodeHeight = NODE_HEADER_HEIGHT;

        // Add height for expanded messages
        if (expandedNodes.has(node.id) && node.messages) {
          nodeHeight += node.messages.reduce((height, msg) => {
            return height + (msg.content.length > 150 ? 160 : 120) + MESSAGE_PADDING;
          }, 0);
        }

        return {
          minX: Math.min(bounds.minX, node.x),
          maxX: Math.max(bounds.maxX, node.x + nodeWidth),
          minY: Math.min(bounds.minY, node.y),
          maxY: Math.max(bounds.maxY, node.y + nodeHeight)
        };
      }, {
        minX: Infinity,
        maxX: -Infinity,
        minY: Infinity,
        maxY: -Infinity
      });
    };

    const viewport = {
      width: canvasRef.current.clientWidth,
      height: canvasRef.current.clientHeight
    };

    // Calculate bounds including expanded messages
    const bounds = calculateExpandedBounds(nodes, expandedNodes);
    if (!bounds || bounds.minX === Infinity) return;

    // Add padding around the content
    const PADDING = 100;
    const contentWidth = bounds.maxX - bounds.minX + (PADDING * 2);
    const contentHeight = bounds.maxY - bounds.minY + (PADDING * 2);

    // Get chat container width
    const chatContainerWidth = getChatContainerWidth();

    // Calculate available canvas width (accounting for chat container)
    const availableWidth = viewport.width - chatContainerWidth;

    // Calculate ideal scale
    const scaleX = (availableWidth * 0.9) / contentWidth;
    const scaleY = (viewport.height * 0.9) / contentHeight;
    const newScale = Math.min(Math.min(scaleX, scaleY), 1);

    // Calculate center position
    const centerX = bounds.minX + (contentWidth / 2);
    const centerY = bounds.minY + (contentHeight / 2);

    // Calculate translation to center the content
    const newTranslate = {
      x: (availableWidth / 2) - (centerX * newScale) + (PADDING * newScale),
      y: (viewport.height / 2) - (centerY * newScale) + (PADDING * newScale)
    };

    // Update viewport
    setScale(newScale);
    setTranslate(newTranslate);
  }, [nodes, expandedNodes, getChatContainerWidth]);

  const organizeNodesIntoStack = useCallback(() => {
    // Spacing constants
    const LEVEL_HORIZONTAL_SPACING = 500;
    const MESSAGE_VERTICAL_SPACING = 120; // Base spacing per message
    const BRANCH_VERTICAL_PADDING = 50;   // Extra padding between branch groups
    const INITIAL_OFFSET_X = 200;
    const INITIAL_OFFSET_Y = 100;

    // Find the root (main) node
    const rootNode = nodes.find(node => node.type === 'main');
    if (!rootNode) return;

    // Group branches by their parent message index
    const branchesByMessage = new Map();
    nodes.forEach(node => {
      if (node.type === 'branch' && node.parentId === rootNode.id) {
        const messageIndex = node.parentMessageIndex || 0;
        if (!branchesByMessage.has(messageIndex)) {
          branchesByMessage.set(messageIndex, []);
        }
        branchesByMessage.get(messageIndex).push(node);
      }
    });

    // Calculate vertical position based on message index
    const getMessageY = (messageIndex) => {
      return INITIAL_OFFSET_Y + (messageIndex * MESSAGE_VERTICAL_SPACING);
    };

    // Process nodes recursively to maintain hierarchy
    const processNode = (node, level, branchGroup = null) => {
      let x = INITIAL_OFFSET_X + (level * LEVEL_HORIZONTAL_SPACING);
      let y;

      if (node.type === 'main') {
        // Position main thread
        y = INITIAL_OFFSET_Y;
      } else {
        // Position branch based on parent message
        const messageY = getMessageY(node.parentMessageIndex);
        const branchesAtMessage = branchesByMessage.get(node.parentMessageIndex) || [];
        const branchIndex = branchesAtMessage.findIndex(b => b.id === node.id);

        // Add vertical offset based on branch position within message group
        y = messageY + (branchIndex * BRANCH_VERTICAL_PADDING);
      }

      // Update node position
      const updatedNode = {
        ...node,
        x,
        y
      };

      // Process child branches
      const childBranches = nodes.filter(n => n.parentId === node.id);
      const processedChildren = childBranches.map((child, index) => {
        return processNode(child, level + 1, {
          parentY: y,
          index,
          total: childBranches.length
        });
      });

      return {
        node: updatedNode,
        children: processedChildren
      };
    };

    // Process all nodes starting from root
    const processedStructure = processNode(rootNode, 0);

    // Flatten the processed structure back into an array
    const flattenStructure = (structure) => {
      const nodes = [structure.node];
      structure.children.forEach(child => {
        nodes.push(...flattenStructure(child));
      });
      return nodes;
    };

    const newNodes = flattenStructure(processedStructure);

    // Update nodes
    setNodes(newNodes);

    // Center view on the organized structure
    if (canvasRef.current) {
      const canvasRect = canvasRef.current.getBoundingClientRect();

      // Calculate bounds
      const bounds = {
        minX: Math.min(...newNodes.map(n => n.x)),
        maxX: Math.max(...newNodes.map(n => n.x)),
        minY: Math.min(...newNodes.map(n => n.y)),
        maxY: Math.max(...newNodes.map(n => n.y))
      };

      // Calculate structure dimensions and center
      const structureWidth = bounds.maxX - bounds.minX + 800; // Add padding
      const structureHeight = bounds.maxY - bounds.minY + 400; // Add padding
      const structureCenterX = (bounds.minX + bounds.maxX) / 2;
      const structureCenterY = (bounds.minY + bounds.maxY) / 2;

      // Calculate ideal scale
      const scaleX = (canvasRect.width * 0.8) / structureWidth;
      const scaleY = (canvasRect.height * 0.8) / structureHeight;
      const newScale = Math.min(Math.min(scaleX, scaleY), 1);

      // Update viewport
      setScale(newScale);
      setTranslate({
        x: (canvasRect.width / 2) - (structureCenterX * newScale),
        y: (canvasRect.height / 2) - (structureCenterY * newScale)
      });
    }
  }, [nodes]);

  const NODE_WIDTH = 400;
  const NODE_HEADER_HEIGHT = 80;
  const MESSAGE_PADDING = 16;


  const getConnectionPoints = (sourceNode, targetNode, expandedNodes) => {

    const isSourceExpanded = expandedNodes.has(sourceNode.id);
    const messageIndex = targetNode.parentMessageIndex || 0;

    // Calculate vertical offset based on message position
    const messageOffset = isSourceExpanded
      ? NODE_HEADER_HEIGHT + (messageIndex * (120 + MESSAGE_PADDING))
      : NODE_HEADER_HEIGHT;

    // Determine if target is to the left or right of source
    const isTargetOnLeft = targetNode.x < sourceNode.x;

    // Calculate horizontal connection points with proper node width
    const sourceX = isTargetOnLeft
      ? sourceNode.x // Left edge of source
      : sourceNode.x + NODE_WIDTH; // Right edge of source

    const targetX = isTargetOnLeft
      ? targetNode.x + NODE_WIDTH // Right edge of target
      : targetNode.x; // Left edge of target

    // Calculate vertical positions with header height consideration
    const sourceY = sourceNode.y + messageOffset;
    const targetY = targetNode.y + (NODE_HEADER_HEIGHT / 2); // Center of target node header

    return {
      x1: sourceX,
      y1: sourceY,
      x2: targetX,
      y2: targetY,
      isTargetOnLeft
    };
  };

  // Calculate the bounding box of all nodes
  const calculateNodesBounds = (nodes) => {
    if (!nodes.length) return null;

    return nodes.reduce((bounds, node) => {
      const nodeWidth = 256; // Fixed node width
      const nodeHeight = 100; // Base node height

      // Update bounds
      return {
        minX: Math.min(bounds.minX, node.x),
        maxX: Math.max(bounds.maxX, node.x + nodeWidth),
        minY: Math.min(bounds.minY, node.y),
        maxY: Math.max(bounds.maxY, node.y + nodeHeight)
      };
    }, {
      minX: Infinity,
      maxX: -Infinity,
      minY: Infinity,
      maxY: -Infinity
    });
  };


  // Calculate the ideal scale to fit content
  const calculateIdealScale = (bounds, viewport, padding = 100) => {
    if (!bounds) return 1;

    const contentWidth = bounds.maxX - bounds.minX + padding * 2;
    const contentHeight = bounds.maxY - bounds.minY + padding * 2;

    // Get the current chat container width
    const chatContainerWidth = getChatContainerWidth(); // We'll create this function

    // Calculate scale based on both dimensions, accounting for chat container
    const scaleX = (viewport.width - chatContainerWidth) / contentWidth;
    const scaleY = viewport.height / contentHeight;

    // Use the smaller scale to ensure content fits
    return Math.min(Math.min(scaleX, scaleY), 1);
  };

  // Calculate the translation to center content
  const calculateCenteringTranslation = (bounds, viewport, scale, padding = 100) => {
    if (!bounds) return { x: 0, y: 0 };

    const contentWidth = (bounds.maxX - bounds.minX + padding * 2) * scale;
    const contentHeight = (bounds.maxY - bounds.minY + padding * 2) * scale;

    // Get the current chat container width
    const chatContainerWidth = getChatContainerWidth();

    // Calculate the available canvas width
    const availableWidth = viewport.width - chatContainerWidth;

    // Center horizontally in the available space, accounting for chat container
    const x = (availableWidth / 2) - (bounds.minX * scale) - (contentWidth / 2) + padding * scale;

    // Center vertically
    const y = (viewport.height / 2) - (bounds.minY * scale) - (contentHeight / 2) + padding * scale;

    return { x, y };
  };

  const getBezierPath = (points) => {
    const { x1, y1, x2, y2, isTargetOnLeft } = points;

    // Calculate the horizontal distance between the points
    const dx = x2 - x1;

    // Adjust control points based on relative positions
    const distance = Math.abs(dx);
    const offset = Math.min(distance * 0.5, 200);

    // Create control points that produce a more natural curve
    const cp1x = x1 + (isTargetOnLeft ? -offset : offset);
    const cp1y = y1;
    const cp2x = x2 + (isTargetOnLeft ? offset : -offset);
    const cp2y = y2;

    return `M ${x1},${y1} C ${cp1x},${cp1y} ${cp2x},${cp2y} ${x2},${y2}`;
  };

  const Connection = ({ sourceNode, targetNode, expandedNodes }) => {
    if (!sourceNode || !targetNode) return null;

    // Get connection points with relative position info
    const points = getConnectionPoints(sourceNode, targetNode, expandedNodes);

    // Generate the path
    const path = getBezierPath(points);

    // Set opacity based on expansion state
    const opacity = expandedNodes.has(sourceNode.id) ? 1 : 0.5;

    return (
      <path
        d={path}
        className="stroke-primary dark:stroke-primary"
        style={{
          opacity,
          transition: 'all 0.2s ease-in-out'
        }}
        strokeWidth="2"
        fill="none"
      />
    );
  };

  // Helper function to calculate message offset (unchanged but included for completeness)

  const calculateMessageOffset = (messageIndex) => {
    const BASE_OFFSET = 80; // Header height
    const MESSAGE_HEIGHT = 120;
    const MESSAGE_PADDING = 16;
    return BASE_OFFSET + (messageIndex * (MESSAGE_HEIGHT + MESSAGE_PADDING));
  };

  const createBranch = (parentNode, template, nodes, messageIndex, position = null) => {
    const NODE_SPACING = 400; // Horizontal spacing between nodes
    const newId = nodes.length > 0 ? Math.max(...nodes.map(n => n.id)) + 1 : 1;
    const contextMessages = parentNode.messages.slice(0, messageIndex + 1);

    // Calculate optimal position if not provided
    const defaultPosition = {
      x: position?.x ?? parentNode.x + NODE_SPACING,
      y: position?.y ?? parentNode.y + calculateMessageOffset(messageIndex)
    };

    // Adjust position to prevent overlap with existing nodes
    const adjustedPosition = adjustNodePosition(defaultPosition, nodes, NODE_SPACING);

    return {
      id: newId,
      messages: [parentNode.messages[messageIndex]],
      x: adjustedPosition.x,
      y: adjustedPosition.y,
      type: 'branch',
      title: template.title || `Branch ${newId}`,
      parentId: parentNode.id,
      systemPrompt: template.systemPrompt,
      collapsed: true,
      parentMessageIndex: messageIndex,
      contextMessages: contextMessages
    };
  };

  const adjustNodePosition = (position, nodes, spacing) => {
    const OVERLAP_THRESHOLD = spacing / 2;
    let adjustedPosition = { ...position };
    let hasOverlap;

    do {
      hasOverlap = false;
      for (const node of nodes) {
        const distance = Math.sqrt(
          Math.pow(node.x - adjustedPosition.x, 2) +
          Math.pow(node.y - adjustedPosition.y, 2)
        );

        if (distance < OVERLAP_THRESHOLD) {
          hasOverlap = true;
          // Shift position diagonally
          adjustedPosition.x += spacing / 2;
          adjustedPosition.y += spacing / 4;
          break;
        }
      }
    } while (hasOverlap);

    return adjustedPosition;
  };


  const getConnectedBranches = (nodeId, messageIndex) => {
    const currentNode = nodes.find(n => n.id === nodeId);
    if (!currentNode) return { left: [], right: [], parent: null };

    // Get parent info
    const parent = currentNode.parentId ? nodes.find(n => n.id === currentNode.parentId) : null;
    const parentPosition = parent ? getNodePosition(currentNode, parent) : null;

    // Get all child branches at current message
    const children = nodes.filter(n =>
      n.parentId === currentNode.id &&
      n.parentMessageIndex === messageIndex
    );

    // Sort children by x position
    const leftBranches = children.filter(n => n.x < currentNode.x)
      .sort((a, b) => b.x - a.x); // Sort from closest to furthest
    const rightBranches = children.filter(n => n.x >= currentNode.x)
      .sort((a, b) => a.x - b.x); // Sort from closest to furthest

    return {
      left: leftBranches,
      right: rightBranches,
      parent: parent ? { node: parent, position: parentPosition } : null
    };
  };

  const handleNavigation = useCallback((direction) => {
    const currentNode = nodes.find(n => n.id === selectedNode);
    if (!currentNode) return;

    const branches = getConnectedBranches(selectedNode, focusedMessageIndex);
    const siblingBranches = getSiblingBranches(selectedNode);

    switch (direction) {
      case 'up': {
        if (focusedMessageIndex > 0) {
          // Regular message navigation
          focusOnMessage(selectedNode, focusedMessageIndex - 1);
        } else {
          // Try to find a sibling branch above
          const siblingAbove = siblingBranches.reverse().find(n => n.y < currentNode.y);
          if (siblingAbove) {
            // Jump to the last message of the sibling branch above
            const siblingMessages = siblingAbove.messages.length;
            focusOnMessage(siblingAbove.id, Math.max(0, siblingMessages - 1));
          }
        }
        break;
      }

      case 'down': {
        if (focusedMessageIndex < currentNode.messages.length - 1) {
          // Regular message navigation
          focusOnMessage(selectedNode, focusedMessageIndex + 1);
        } else {
          // Try to find a sibling branch below
          const siblingBelow = siblingBranches.find(n => n.y > currentNode.y);
          if (siblingBelow) {
            // Jump to the first message of the sibling branch below
            focusOnMessage(siblingBelow.id, 0);
          }
        }
        break;
      }

      case 'left': {
        if (branches.parent?.position === 'left') {
          focusOnMessage(branches.parent.node.id, currentNode.parentMessageIndex);
        } else if (branches.left.length > 0) {
          const currentIndex = branches.left.findIndex(n => n.id === selectedNode);
          const nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % branches.left.length;
          focusOnMessage(branches.left[nextIndex].id, 0);
        }
        break;
      }

      case 'right': {
        if (branches.parent?.position === 'right') {
          focusOnMessage(branches.parent.node.id, currentNode.parentMessageIndex);
        } else if (branches.right.length > 0) {
          const currentIndex = branches.right.findIndex(n => n.id === selectedNode);
          const nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % branches.right.length;
          focusOnMessage(branches.right[nextIndex].id, 0);
        }
        break;
      }
    }
  }, [nodes, selectedNode, focusedMessageIndex, focusOnMessage, getConnectedBranches, getSiblingBranches]);


  // Add this useEffect for the keyboard listener
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Only show quick input if user is not already typing somewhere
      const isTyping = document.activeElement.tagName === 'INPUT' ||
        document.activeElement.tagName === 'TEXTAREA' ||
        document.activeElement.closest('.chat-interface');

      if (isTyping) return;

      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        setQuickInputPosition({ x: e.clientX, y: e.clientY });
        setShowQuickInput(true);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (document.activeElement.tagName === 'INPUT' ||
        document.activeElement.tagName === 'TEXTAREA') return;

      if (!selectedNode) return;

      const currentNode = nodes.find(n => n.id === selectedNode);
      if (!currentNode) return;

      const isShiftPressed = e.shiftKey;
      const branches = getConnectedBranches(selectedNode, focusedMessageIndex);
      const siblingBranches = getSiblingBranches(selectedNode);

      switch (e.key.toLowerCase()) {
        case 'w': {
          if (focusedMessageIndex > 0) {
            focusOnMessage(selectedNode, focusedMessageIndex - 1, isShiftPressed);
          } else {
            const siblingAbove = siblingBranches.reverse().find(n => n.y < currentNode.y);
            if (siblingAbove) {
              const siblingMessages = siblingAbove.messages.length;
              focusOnMessage(siblingAbove.id, Math.max(0, siblingMessages - 1), isShiftPressed);
            }
          }
          break;
        }

        case 's': {
          if (focusedMessageIndex < currentNode.messages.length - 1) {
            focusOnMessage(selectedNode, focusedMessageIndex + 1, isShiftPressed);
          } else {
            const siblingBelow = siblingBranches.find(n => n.y > currentNode.y);
            if (siblingBelow) {
              focusOnMessage(siblingBelow.id, 0, isShiftPressed);
            }
          }
          break;
        }

        case 'a': {
          if (branches.parent?.position === 'left') {
            focusOnMessage(branches.parent.node.id, currentNode.parentMessageIndex, isShiftPressed);
          } else if (branches.left.length > 0) {
            const currentIndex = branches.left.findIndex(n => n.id === selectedNode);
            const nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % branches.left.length;
            focusOnMessage(branches.left[nextIndex].id, 0, isShiftPressed);
          }
          break;
        }

        case 'd': {
          if (branches.parent?.position === 'right') {
            focusOnMessage(branches.parent.node.id, currentNode.parentMessageIndex, isShiftPressed);
          } else if (branches.right.length > 0) {
            const currentIndex = branches.right.findIndex(n => n.id === selectedNode);
            const nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % branches.right.length;
            focusOnMessage(branches.right[nextIndex].id, 0, isShiftPressed);
          }
          break;
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedNode, focusedMessageIndex, nodes, focusOnMessage, getConnectedBranches, getSiblingBranches]);

  const getNodePosition = (sourceNode, targetNode) => {
    return targetNode.x < sourceNode.x ? 'left' : 'right';
  };


  useEffect(() => {
    const handleKeyDown = (e) => {
      // Check if the active element is a text input or textarea
      const isTyping = document.activeElement.tagName === 'INPUT' ||
        document.activeElement.tagName === 'TEXTAREA';

      // If user is typing in an input field, only handle shortcuts with modifier keys
      if (isTyping && !e.ctrlKey && !e.metaKey) {
        return;
      }

      // Handle all keyboard shortcuts in one place
      switch (e.key.toLowerCase()) {
        case 'c':
          centerCanvas();
          break;
        case 'o':
          if (!e.ctrlKey && !e.metaKey) {
            e.preventDefault(); // Prevent saving
            organizeNodesIntoStack();
          }
          break;
        case 'g':
          setActiveTool('select');
          break;
        case 'h':
          setActiveTool('pan');
          break;
        case 's':
          setActiveTool('select');
          break;
        case ' ':
          if (activeTool === 'pan') {
            setActiveTool('pan');
          }
          break;
      }
    };


    const handleKeyUp = (e) => {
      // Only handle space key for pan tool when not typing
      const isTyping = document.activeElement.tagName === 'INPUT' ||
        document.activeElement.tagName === 'TEXTAREA';

      if (!isTyping && e.key === ' ' && activeTool === 'pan') {
        setActiveTool('select');
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [centerCanvas, organizeNodesIntoStack, activeTool, isModelDropdownOpen]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    // Add the wheel event listener with passive: false to allow preventDefault
    canvas.addEventListener('wheel', handleWheel, { passive: false });

    return () => {
      canvas.removeEventListener('wheel', handleWheel, { passive: false });
    };
  }, [handleWheel]);

  const handleToggleExpand = useCallback((nodeId) => {
    setExpandedNodes(prev => {
      const newSet = new Set(prev);
      if (newSet.has(nodeId)) {
        newSet.delete(nodeId);
      } else {
        newSet.add(nodeId);
      }
      return newSet;
    });
  }, []);

  useEffect(() => {
    const handleMouseMove = (e) => {
      if (dragState.isDragging) {
        handleDrag(e);
      } else if (isPanning) {
        const dx = (e.clientX - lastMousePos.x) * PANNING_SENSITIVITY;
        const dy = (e.clientY - lastMousePos.y) * PANNING_SENSITIVITY;

        setTranslate(prev => ({
          x: prev.x + dx,
          y: prev.y + dy
        }));

        setLastMousePos({ x: e.clientX, y: e.clientY });
      }
    };

    const handleMouseUp = () => {
      if (dragState.isDragging) {
        handleDragEnd();
      }
      setIsPanning(false);
    };

    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);

    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [dragState, isPanning, handleDrag, handleDragEnd, lastMousePos]);


  return (
    <div className="relative flex h-full bg-background overflow-hidden">
      {/* Canvas Area with Grid and Interactions */}
      <div
        ref={canvasRef}
        className={cn(
          "absolute inset-0 overflow-hidden select-none",
          isPanning ? "cursor-grabbing" : activeTool === "pan" ? "cursor-grab" : "cursor-default"
        )}
        onMouseDown={handleCanvasMouseDown}
        style={{ touchAction: 'none' }}
      >
        {/* Background Grid */}
        <GridBackground
          translate={translate}
          scale={scale}
          className="stroke-border dark:stroke-border"
        />

        {/* Toolbar - Fixed with Dynamic Positioning */}
        <div
          className="fixed bottom-20 z-10"
          style={{
            left: isPanelCollapsed ? '1rem' : 'calc(20vw + 1rem)'
          }}
        >
          <CanvasToolbar
            activeTool={activeTool}
            onToolSelect={handleToolSelect}
            theme={theme}
            onThemeChange={handleThemeChange}
            selectedModel={selectedModel}
            models={models}
            onModelSelect={setSelectedModel}
            isModelDropdownOpen={isModelDropdownOpen}
            setIsModelDropdownOpen={setIsModelDropdownOpen}
            modelDropdownRef={modelDropdownRef}
          />
        </div>

        {/* Bottom Navigation Bar - Fixed with Dynamic Positioning */}
        <div
          className="fixed bottom-1 mx-2 z-10 flex gap-2 right: 10px width: -webkit-fill-available justify-content: space-around"
          style={{
            left: isPanelCollapsed ? '1rem' : 'calc(20vw + 1rem)'
          }}
        >
          <MessageNavigator
            currentNode={nodes.find(n => n.id === selectedNode)}
            currentIndex={focusedMessageIndex}
            totalMessages={nodes.find(n => n.id === selectedNode)?.messages.length || 0}
            onNavigate={handleNavigation}
            branches={getConnectedBranches(selectedNode, focusedMessageIndex)}
            isMessageExpanded={expandedMessages.has(focusedMessageIndex)}
            onToggleExpand={handleToggleMessageExpand}
          />
        </div>

        {/* Canvas Content - Nodes and Connections */}
        <div ref={contentRef}
          className="absolute inset-0 z-0"
          style={{
            transform: `translate(${translate.x}px, ${translate.y}px) scale(${scale})`,
            transformOrigin: '0 0',
          }}
        >
          {/* SVG Layer for Connections */}
          <svg
            className="absolute"
            style={{
              width: '100%',
              height: '100%',
              overflow: 'visible',
              pointerEvents: 'none'
            }}
          >
            {nodes.map((node) => {
              if (!node.parentId) return null;
              const parent = nodes.find(n => n.id === node.parentId);
              if (!parent) return null;
              return (
                <Connection
                  key={`connection-${parent.id}-${node.id}`}
                  sourceNode={parent}
                  targetNode={node}
                  expandedNodes={expandedNodes}
                />
              );
            })}
          </svg>

          {/* Node Components */}
          {nodes.map((node) => (
            <BranchNode
              key={`node-${node.id}-${node.branchId || '0'}`}
              node={node}
              nodes={nodes}
              isExpanded={expandedNodes.has(node.id)}
              isSelected={selectedNode === node.id}
              onToggleExpand={() => handleToggleExpand(node.id)}
              onSelect={() => setSelectedNode(node.id)}
              onDelete={() => handleDeleteNode(node.id)}
              onDragStart={handleDragStart}
              onCreateBranch={handleCreateBranch}
              selectedModel={selectedModel}
              currentMessageIndex={node.id === selectedNode ? focusedMessageIndex : null}
              branchId={node.branchId}
              expandedMessages={expandedMessages}
              onToggleMessageExpand={handleToggleMessageExpand}
              onUpdateTitle={handleUpdateTitle}
              style={{
                position: 'absolute',
                left: `${node.x}px`,
                top: `${node.y}px`,
                width: '400px',
                zIndex: selectedNode === node.id ? 10 : 1
              }}
            />
          ))}

        </div>
      </div>

      {/* Chat Sidebar */}
      <ChatContainer
        size={chatContainerSize}
        onSizeChange={setChatContainerSize}
      >
        <ModelStatus
          selectedModel={selectedModel}
          isLoading={isLoading}
          temperature={temperature}
          onTemperatureChange={setTemperature}
          models={models}
          onModelSelect={setSelectedModel}
          containerWidth={containerWidth}
        />
        {selectedNode && (
          <ChatInterface
            messages={getFullMessageHistory(selectedNode)}
            input={inputValue}
            isLoading={isLoading}
            onInputChange={handleInputChange}
            onSend={handleSendMessage}
            streamingMessage={streamingMessage}
            continuationCount={continuationCount}
            activeNode={nodes.find(n => n.id === selectedNode)}
            expandedMessages={expandedMessages} // Add this prop
            onToggleMessageExpand={handleToggleMessageExpand} // Add this prop
          />
        )}
      </ChatContainer>

      <FloatingInput
        show={showQuickInput}
        onClose={() => setShowQuickInput(false)}
        onSend={handleSendMessage}
        isLoading={isLoading}
        position={quickInputPosition}
        inputValue={inputValue}
        onInputChange={handleInputChange}
        style={{
          position: contentHeight > window.innerHeight ? 'fixed' : 'absolute',
          bottom: 20,
          left: '50%',
          transform: 'translateX(-50%)'
        }}
      />
    </div>
  );
};

export default TangentChat;


// ========================================
// File: simplified-ui/src/components/TangentLogo.jsx
// ========================================

import { useEffect, useState, useRef } from 'react';
import { cn } from "./lib/utils";

export function TangentLogo() {
    const [isShowingFront, setIsShowingFront] = useState(true);
    const gridRef = useRef(null);

    const COLS = 15;
    const ROWS = 5;
    const cells = Array.from({ length: ROWS * COLS });

    const logoSVG = (
        <svg viewBox="0 0 200 45" className="absolute inset-0">
            {/* Dynamic wave patterns */}
            <path
                d="M 20 22.5 C 40 22.5, 45 12, 65 12 S 90 33, 110 33 S 135 12, 155 12 S 180 22.5, 200 22.5"
                fill="none"
                className="stroke-foreground dark:stroke-foreground"
                strokeWidth="1"
            />

            {/* Fractal-like pattern */}
            <path
                d="M 100 22.5 C 105 22.5, 110 18, 120 18 S 135 27, 145 27 S 155 18, 165 18"
                fill="none"
                className="stroke-cyan-500 dark:stroke-cyan-400"
                strokeWidth="1"
            />
            <path
                d="M 100 22.5 C 95 22.5, 90 27, 80 27 S 65 18, 55 18 S 45 27, 35 27"
                fill="none"
                className="stroke-rose-500 dark:stroke-rose-400"
                strokeWidth="1"
            />

            {/* Geometric accents */}
            {[...Array(8)].map((_, i) => (
                <path
                    key={i}
                    d={`M ${100 + i * 10} 22.5 L ${105 + i * 10} 15 L ${110 + i * 10
                        } 22.5`}
                    fill="none"
                    className="stroke-emerald-500/30 dark:stroke-emerald-400/30"
                    strokeWidth="0.5"
                />
            ))}
            {[...Array(8)].map((_, i) => (
                <path
                    key={i}
                    d={`M ${100 - i * 10} 22.5 L ${95 - i * 10} 30 L ${90 - i * 10
                        } 22.5`}
                    fill="none"
                    className="stroke-purple-500/30 dark:stroke-purple-400/30"
                    strokeWidth="0.5"
                />
            ))}

            {/* Dynamic circles */}
            {[...Array(5)].map((_, i) => (
                <circle
                    key={i}
                    cx={100 + i * 20}
                    cy={22.5 + Math.sin(i * 1.5) * 5}
                    r={1.2 - i * 0.15}
                    className="fill-cyan-500 dark:fill-cyan-400"
                />
            ))}
            {[...Array(5)].map((_, i) => (
                <circle
                    key={i}
                    cx={100 - i * 20}
                    cy={22.5 + Math.cos(i * 1.5) * 5}
                    r={1.2 - i * 0.15}
                    className="fill-rose-500 dark:fill-rose-400"
                />
            ))}

            {/* Central focal point */}
            <path
                d="M 95 22.5 L 105 22.5 M 100 17.5 L 100 27.5"
                className="stroke-foreground dark:stroke-foreground"
                strokeWidth="1.5"
            />
            <circle
                cx="100"
                cy="22.5"
                r="2.5"
                className="fill-foreground dark:fill-foreground"
            />

            {/* Abstract mathematical symbols */}
            <path
                d="M 160 15 A 5 5 0 0 1 170 15 A 5 5 0 0 1 160 15"
                fill="none"
                className="stroke-emerald-500/50 dark:stroke-emerald-400/50"
                strokeWidth="0.75"
            />
            <path
                d="M 30 30 A 5 5 0 0 0 40 30 A 5 5 0 0 0 30 30"
                fill="none"
                className="stroke-purple-500/50 dark:stroke-purple-400/50"
                strokeWidth="0.75"
            />
        </svg>
    );

    // Updated flipCell function
    const flipCell = (cell, delay) => {
        setTimeout(() => {
            if (cell) {
                cell.style.transform = isShowingFront ? 'rotateY(180deg)' : 'rotateY(0deg)';
            }
        }, delay);
    };

    const animateFlip = () => {
        if (!gridRef.current) return;
        const cells = Array.from(gridRef.current.querySelectorAll('.cell'));

        // Organize cells into columns
        const columns = Array.from({ length: COLS }, () => []);

        cells.forEach((cell, index) => {
            const col = index % COLS;
            columns[col].push(cell);
        });

        const delayBetweenColumns = 50; // Adjust the delay as needed

        // Generate the column order
        const middle = Math.floor(COLS / 2);
        let columnOrder = [middle];
        for (let offset = 1; offset <= middle; offset++) {
            if (middle - offset >= 0) columnOrder.push(middle - offset);
            if (middle + offset < COLS) columnOrder.push(middle + offset);
        }

        // If flipping back, reverse the order
        if (!isShowingFront) {
            columnOrder = columnOrder.reverse();
        }

        columnOrder.forEach((colIndex, index) => {
            setTimeout(() => {
                columns[colIndex].forEach((cell) => {
                    flipCell(cell, 0); // No additional delay within the column
                });
            }, index * delayBetweenColumns);
        });

        // Update the state after all flips are done
        setTimeout(() => {
            setIsShowingFront(!isShowingFront);
        }, columnOrder.length * delayBetweenColumns + 500); // +500ms to ensure all animations complete
    };

    useEffect(() => {
        const interval = setInterval(animateFlip, 5000);
        return () => clearInterval(interval);
    }, [isShowingFront]);

    return (
        <div
            className={cn(
                "w-[180px] h-[36px] relative perspective-[1000px] rounded-lg overflow-hidden",
                // Removed bg-card classes to make background transparent
            )}
        >
            <div
                ref={gridRef}
                className={cn(
                    "w-full h-full grid grid-cols-[repeat(15,1fr)] grid-rows-[repeat(5,1fr)]",
                    "relative gap-0"
                )}
            >
                {cells.map((_, i) => {
                    const x = (i % COLS) * (180 / COLS);
                    const y = Math.floor(i / COLS) * (36 / ROWS);

                    return (
                        <div
                            key={i}
                            className="relative [transform-style:preserve-3d] transition-transform duration-1000 ease-in-out cell"
                            style={{
                                border: 'none',
                                backgroundColor: 'transparent',
                            }}
                        >
                            <div
                                className={cn(
                                    "absolute w-full h-full [backface-visibility:hidden] overflow-hidden front"
                                )}
                                style={{
                                    backgroundColor: 'transparent',
                                }}
                            >
                                <div
                                    className="w-[180px] h-[36px] relative"
                                    style={{
                                        transform: `translate(${-x}px, ${-y}px)`,
                                    }}
                                >
                                    {logoSVG}
                                </div>
                            </div>
                            <div
                                className={cn(
                                    "absolute w-full h-full [backface-visibility:hidden] overflow-hidden [transform:rotateY(180deg)] back"
                                )}
                                style={{
                                    backgroundColor: 'transparent',
                                }}
                            >
                                <div
                                    className="absolute w-[180px] h-[36px]"
                                    style={{
                                        transform: `translate(${-x}px, ${-y}px)`,
                                    }}
                                >
                                    <div
                                        className={cn(
                                            "font-sans text-[24px] font-bold w-full h-full ps-4 flex items-center justify-center",
                                            "text-foreground dark:text-foreground"
                                            // Removed bg-clear class
                                        )}
                                    >
                                        TANGENT
                                    </div>
                                </div>
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
}

export default TangentLogo;



// ========================================
// File: simplified-ui/src/components/ThemeToggle.jsx
// ========================================

import React, { useState } from 'react';
import { Sun, Moon, Sparkles, Atom } from 'lucide-react';
import { Button } from './ui/button';
import { motion, AnimatePresence } from 'framer-motion';

export function ThemeToggle({ theme, setTheme }) {
  const [isOpen, setIsOpen] = useState(false);

  const themes = [
    {
      name: 'light',
      icon: Sun,
      label: 'Light',
      className: 'text-amber-500'
    },
    {
      name: 'dark',
      icon: Moon,
      label: 'Dark',
      className: 'text-slate-900 dark:text-slate-100'
    },
    {
      name: 'hextech-nordic',
      icon: Sparkles,
      label: 'Nordic',
      className: 'text-[hsl(195,96%,65%)]'
    },
    {
      name: 'singed-theme',
      icon: Atom,
      label: 'Cyber',
      className: 'text-[hsl(155,70%,35%)]'
    }
  ];

  const currentTheme = themes.find(t => t.name === theme) || themes[0];
  const Icon = currentTheme.icon;

  return (
    <div className="relative">
      <Button
        variant="outline"
        size="icon"
        onClick={() => setIsOpen(!isOpen)}
        className={`w-8 h-8 transition-colors ${
          theme === 'hextech-nordic' ? 'glow pulse' : ''
        }`}
      >
        <Icon className={`h-4 w-4 transition-all ${themes.find(t => t.name === theme)?.className}`} />
        <span className="sr-only">Toggle theme</span>
      </Button>

      <AnimatePresence>
        {isOpen && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.2, ease: "easeOut" }}
            className="absolute right-0 mt-2 origin-top-right"
          >
            <motion.div
              initial={{ scale: 0.95 }}
              animate={{ scale: 1 }}
              exit={{ scale: 0.95 }}
              transition={{ duration: 0.2, ease: "easeOut" }}
              className="w-36 bg-popover border border-border rounded-md shadow-lg overflow-hidden"
            >
              {themes.map((t) => {
                const ThemeIcon = t.icon;
                return (
                  <motion.button
                    key={t.name}
                    onClick={() => {
                      document.documentElement.classList.remove('light', 'dark', 'hextech-nordic', 'singed-theme');
                      document.documentElement.classList.add(t.name);
                      setTheme(t.name);
                      localStorage.setItem('theme', t.name);
                      setIsOpen(false);
                    }}
                    className={`
                      w-full flex items-center gap-2 px-2 py-1.5 text-sm
                      transition-colors hover:bg-accent
                      ${theme === t.name ? 'bg-accent' : ''}
                      ${t.name === 'hextech-nordic' ? 'hover:text-[hsl(195,96%,65%)]' : ''}
                    `}
                    whileHover={{ backgroundColor: 'rgba(0,0,0,0.05)' }}
                    whileTap={{ scale: 0.98 }}
                  >
                    <ThemeIcon className={`h-4 w-4 ${t.className}`} />
                    <span>{t.label}</span>
                  </motion.button>
                );
              })}
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}


// ========================================
// File: simplified-ui/src/components/TopicsPanel.jsx
// ========================================

import React, { useState, useMemo } from 'react';
import { Card, CardHeader, CardTitle } from './ui/card';
import { ScrollArea } from './ui/scroll-area';
import { Button } from './ui/button';
import { Badge } from './index';
import { Progress } from './index';
import { Input } from './ui/input';
import { Switch } from './index';
import { Label } from './index';
import {
  ArrowRight,
  Search,
  SlidersHorizontal,
  TrendingUp,
  Users,
  Target,
  GitBranch,
  ChevronDown,
  MessageSquare
} from 'lucide-react';
import { cn } from './lib/utils';

// Separated TopicCard component
const TopicCard = ({
  cluster,
  topicData,
  isActive,
  topicBranchCounts,
  conversationsByCluster,
  getColor,
  handleTopicSelect,
  onConversationSelect
}) => {
  const [showConversations, setShowConversations] = useState(false);
  const branchInfo = topicBranchCounts[cluster];
  const hasBranches = branchInfo?.conversationsWithBranches > 0;
  const totalBranches = branchInfo?.totalBranches || 0;
  const conversations = conversationsByCluster[cluster] || [];

  return (
    <div className={cn(
      "group rounded-lg transition-all duration-200",
      isActive && "bg-accent shadow-sm"
    )}>
      <div className="p-4 hover:bg-accent/50">
        <div className="flex items-start gap-4">
          <div
            className={cn(
              "h-3 w-3 rounded-full mt-1.5 flex-shrink-0",
              "ring-2 ring-offset-2 ring-offset-background transition-all",
              isActive ? "ring-primary" : "ring-transparent"
            )}
            style={{ backgroundColor: getColor(parseInt(cluster)) }}
          />
          <div className="flex-1 space-y-2">
            <div className="flex items-center justify-between">
              <button
                className="font-medium tracking-tight text-left flex-1 hover:text-primary"
                onClick={() => handleTopicSelect(cluster)}
              >
                {topicData.topic}
              </button>
              
              {isActive && conversations.length > 0 && (
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    setShowConversations(!showConversations);
                  }}
                  className="flex items-center gap-2 text-muted-foreground hover:text-foreground p-1 rounded-md"
                >
                  <MessageSquare className="h-4 w-4" />
                  <span className="text-xs">{conversations.length}</span>
                  <ChevronDown className={cn(
                    "h-4 w-4 transition-transform duration-200",
                    showConversations && "transform rotate-180"
                  )} />
                </button>
              )}
            </div>

            <div className="flex flex-wrap items-center gap-2 text-xs text-muted-foreground">
              <span className="flex items-center gap-1">
                <Users className="h-3 w-3" />
                {topicData.size}
              </span>
              <span className="flex items-center gap-1">
                <TrendingUp className="h-3 w-3" />
                {(topicData.coherence * 100).toFixed(0)}%
              </span>
              {hasBranches && (
                <Badge variant="secondary" className="flex items-center gap-1">
                  <GitBranch className="h-3 w-3" />
                  {totalBranches}
                </Badge>
              )}
            </div>

            <Progress
              value={topicData.coherence * 100}
              className={cn(
                "h-1 transition-all duration-200",
                isActive && "bg-primary/20"
              )}
            />
          </div>
        </div>
      </div>

      {/* Collapsible conversation list */}
      {isActive && showConversations && (
        <div className="w-[300px] px-4 pb-4">
          <div className="pl-7 space-y-2">
            {conversations.map((chat, index) => (
              <Button
                key={index}
                variant="ghost"
                className="w-full justify-start gap-2 h-auto py-2 text-sm font-normal"
                onClick={() => onConversationSelect(chat)}
              >
                <MessageSquare className="h-4 w-4 shrink-0" />
                <span className="truncate text-left">{chat.title}</span>
              </Button>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

// Main TopicsPanel component
const TopicsPanel = ({
  data,
  sortBy,
  setSortBy,
  selectedCluster,
  handleTopicSelect,
  getColor,
  onConversationSelect
}) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [showFilters, setShowFilters] = useState(false);
  const [coherenceThreshold, setCoherenceThreshold] = useState(0);
  const [showOnlyMultiBranch, setShowOnlyMultiBranch] = useState(false);

  const sortOptions = [
    { id: 'relevance', icon: <Target className="h-4 w-4" />, label: 'Relevance' },
    { id: 'size', icon: <Users className="h-4 w-4" />, label: 'Size' },
    { id: 'coherence', icon: <TrendingUp className="h-4 w-4" />, label: 'Coherence' },
    { id: 'branches', icon: <GitBranch className="h-4 w-4" />, label: 'Branches' }
  ];

  // Group conversations by cluster
  const conversationsByCluster = useMemo(() => {
    if (!data?.chartData?.[0]?.data) return {};

    return data.chartData[0].data.reduce((acc, chat) => {
      const clusterId = chat.cluster.toString();
      if (!acc[clusterId]) {
        acc[clusterId] = [];
      }
      acc[clusterId].push(chat);
      return acc;
    }, {});
  }, [data]);

  const topicBranchCounts = useMemo(() => {
    if (!data?.chartData?.[0]?.data) return {};

    const counts = {};
    data.chartData[0].data.forEach(chat => {
      const clusterId = chat.cluster.toString();
      const baseTitle = chat.title.replace(/ \(Branch \d+\)$/, '');

      if (!counts[clusterId]) {
        counts[clusterId] = {
          branchMap: new Map(),
          totalBranches: 0,
          conversationsWithBranches: 0
        };
      }

      const branchMap = counts[clusterId].branchMap;
      if (!branchMap.has(baseTitle)) {
        branchMap.set(baseTitle, 1);
      } else {
        branchMap.set(baseTitle, branchMap.get(baseTitle) + 1);
        if (branchMap.get(baseTitle) === 2) {
          counts[clusterId].conversationsWithBranches++;
        }
        counts[clusterId].totalBranches++;
      }
    });

    return counts;
  }, [data]);

  const filteredAndSortedTopics = useMemo(() => {
    if (!data?.topics) return [];

    return Object.entries(data.topics)
      .filter(([id, topicData]) => {
        const matchesSearch = topicData.topic.toLowerCase().includes(searchQuery.toLowerCase());
        const meetsCoherence = topicData.coherence * 100 >= coherenceThreshold;
        const hasBranches = topicBranchCounts[id]?.conversationsWithBranches > 0;
        const meetsMultiBranch = !showOnlyMultiBranch || hasBranches;
        return matchesSearch && meetsCoherence && meetsMultiBranch;
      })
      .sort((a, b) => {
        const [idA, topicA] = a;
        const [idB, topicB] = b;
        const branchesA = topicBranchCounts[idA]?.totalBranches || 0;
        const branchesB = topicBranchCounts[idB]?.totalBranches || 0;

        switch (sortBy) {
          case "size":
            return topicB.size - topicA.size;
          case "coherence":
            return topicB.coherence - topicA.coherence;
          case "branches":
            return branchesB - branchesA;
          default:
            return (topicB.size * topicB.coherence) - (topicA.size * topicA.coherence);
        }
      });
  }, [data, searchQuery, sortBy, coherenceThreshold, showOnlyMultiBranch, topicBranchCounts]);

  return (
    <Card className="h-[700px] h-[90vh] flex flex-col">
      <CardHeader className="border-b space-y-4 pb-4 flex-shrink-0">
        <div className="flex items-center justify-between">
          <CardTitle>Topics Overview</CardTitle>
          <Badge variant="outline" className="font-normal">
            {filteredAndSortedTopics.length} of {Object.keys(data?.topics || {}).length}
          </Badge>
        </div>

        <div className="space-y-3">
          <div className="flex items-center gap-2">
            <div className="relative flex-1">
              <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
              <Input
                type="search"
                placeholder="Search topics..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-8"
              />
            </div>

            <Button
              variant="outline"
              size="sm"
              className={cn("shrink-0 gap-1", showFilters && "bg-accent")}
              onClick={() => setShowFilters(!showFilters)}
            >
              <SlidersHorizontal className="h-4 w-4" />
            </Button>
          </div>

          <div className="flex items-center gap-2">
            <div className="flex gap-1 flex-1 flex-wrap">
              {sortOptions.map(({ id, icon, label }) => (
                <Button
                  key={id}
                  variant={sortBy === id ? "default" : "outline"}
                  size="sm"
                  className={cn(
                    "text-xs flex items-center gap-1",
                    sortBy === id && "shadow-sm"
                  )}
                  onClick={() => setSortBy(id)}
                >
                  {icon}
                  {label}
                </Button>
              ))}
            </div>
          </div>

          {showFilters && (
            <div className="pt-2 border-t space-y-3">
              <div className="space-y-2">
                <label className="text-sm text-muted-foreground">
                  Minimum Coherence: {coherenceThreshold}%
                </label>
                <input
                  type="range"
                  min="0"
                  max="100"
                  value={coherenceThreshold}
                  onChange={(e) => setCoherenceThreshold(parseInt(e.target.value))}
                  className="w-full"
                />
              </div>

              <div className="flex items-center gap-2">
                <Switch
                  id="multi-branch-filter"
                  checked={showOnlyMultiBranch}
                  onCheckedChange={setShowOnlyMultiBranch}
                />
                <Label htmlFor="multi-branch-filter" className="text-sm text-muted-foreground">
                  Show only topics with branches
                </Label>
              </div>
            </div>
          )}
        </div>
      </CardHeader>
      <ScrollArea className="flex-1">
        <div className="p-2 space-y-1">
          {filteredAndSortedTopics.length > 0 ? (
            filteredAndSortedTopics.map(([cluster, topicData]) => (
              <TopicCard
                key={cluster}
                cluster={cluster}
                topicData={topicData}
                isActive={parseInt(cluster) === selectedCluster}
                topicBranchCounts={topicBranchCounts}
                conversationsByCluster={conversationsByCluster}
                getColor={getColor}
                handleTopicSelect={handleTopicSelect}
                onConversationSelect={onConversationSelect}
              />
            ))
          ) : (
            <div className="p-8 text-center text-muted-foreground">
              No topics match your criteria
            </div>
          )}
        </div>
      </ScrollArea>
    </Card>
  );
};

export default TopicsPanel;


// ========================================
// File: simplified-ui/src/components/TypeSelector.jsx
// ========================================

import React, { useState, useContext, useCallback } from "react";
import {
    Loader2,
    ChevronDown,
    MessageCircle,
    Bot,
    AlertCircle,
    Network,
    Grid
} from "lucide-react";
import { Alert, AlertDescription } from "./ui/alert";

export const ChatTypeSelector = ({ chatType, setChatType, onDataUpdate }) => {
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);

    const fetchVisualizationData = useCallback(async (type) => {
        const url = `http://127.0.0.1:5001/api/visualization?type=${type}`;
        console.log("Fetching from:", url);
        
        try {
            const response = await fetch(url);
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
            }

            const responseData = await response.json();
            
            // Validate the response data
            if (!responseData.points || !responseData.clusters || !responseData.titles) {
                throw new Error("Invalid data structure received from server");
            }

            return responseData;
        } catch (error) {
            throw error;
        }
    }, []);

    const handleTypeChange = useCallback(async (newType) => {
        setError(null);
        setIsLoading(true);
        console.log("Changing chat type to:", newType);

        try {
            // First update the chat type state
            setChatType(newType);

            // Then fetch new data
            const responseData = await fetchVisualizationData(newType);
            console.log("Received data:", responseData);

            const chatsWithReflections = new Set(responseData.chats_with_reflections || []);

            // Transform the data
            const chartData = [{
                id: 'points',
                data: responseData.points.map((point, i) => ({
                    x: point[0],
                    y: point[1],
                    cluster: responseData.clusters[i],
                    title: responseData.titles[i],
                    hasReflection: chatsWithReflections.has(responseData.titles[i]),
                    type: newType // Add chat type to each point
                }))
            }];

            // Update visualization with new data
            onDataUpdate({
                chartData,
                topics: responseData.topics,
                currentType: newType // Add current chat type to the data
            });

        } catch (error) {
            console.error('Error changing chat type:', error);
            setError(error.message);
            // Revert chat type on error
            setChatType(chatType);
        } finally {
            setIsLoading(false);
        }
    }, [chatType, setChatType, onDataUpdate, fetchVisualizationData]);

    return (
        <div className="relative">
            <button
                className="flex h-8 w-[90px] items-center justify-between rounded-md border bg-background px-3 py-2 text-sm hover:bg-accent transition-colors disabled:opacity-50"
                onClick={() => handleTypeChange(chatType === 'claude' ? 'chatgpt' : 'claude')}
                disabled={isLoading}
            >
                <div className="flex items-center gap-2">
                    {isLoading ? (
                        <Loader2 className="h-4 w-4 animate-spin" />
                    ) : (
                        <>
                            {chatType === 'claude' ? (
                                <Bot className="h-4 w-4" />
                            ) : (
                                <MessageCircle className="h-4 w-4" />
                            )}
                            {chatType === 'claude' ? 'Claude' : 'ChatGPT'}
                        </>
                    )}
                </div>
                <ChevronDown className="h-4 w-4" />
            </button>

            {error && (
                <Alert variant="destructive" className="mt-2 absolute top-full left-0 right-0 z-50">
                    <AlertCircle className="h-4 w-4" />
                    <AlertDescription>
                        {error}
                    </AlertDescription>
                </Alert>
            )}
        </div>
    );
};


export const VisualizationTypeSelector = ({ visualizationType, setVisualizationType }) => {
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);

    const handleTypeChange = async (newType) => {
        setError(null);
        setIsLoading(true);

        try {
            setVisualizationType(newType);
        } catch (error) {
            console.error('Error changing visualization type:', error);
            setError(error.message);
            // Revert visualization type on error
            setVisualizationType(visualizationType);
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="relative">
            <button
                className="flex h-8 w-[90px] items-center justify-between rounded-md border bg-background px-3 py-2 text-sm hover:bg-accent transition-colors disabled:opacity-50"
                onClick={() => handleTypeChange(visualizationType === 'star' ? 'islands' : 'star')}
                disabled={isLoading}
            >
                <div className="flex items-center gap-2">
                    {isLoading ? (
                        <Loader2 className="h-4 w-4 animate-spin" />
                    ) : (
                        <>
                            {visualizationType === 'star' ? (
                                <Network className="h-4 w-4" />
                            ) : (
                                <Grid className="h-4 w-4" />
                            )}
                            {visualizationType === 'star' ? 'Normal' : 'Islands'}
                        </>
                    )}
                </div>
                <ChevronDown className="h-4 w-4" />
            </button>

            {error && (
                <Alert variant="destructive" className="mt-2 absolute top-full left-0 right-0 z-50">
                    <AlertDescription>
                        {error}
                    </AlertDescription>
                </Alert>
            )}
        </div>
    );
};


// ========================================
// File: simplified-ui/src/components/VisualizationPanel.jsx
// ========================================

import React, { useState, useCallback, useMemo, useRef, useEffect } from 'react';
import * as d3 from "d3";
import { Button } from './ui/button';
import { RefreshCw, Plus, Minus, Search, Maximize2, Minimize2 } from 'lucide-react';
import { ChatTypeSelector, VisualizationTypeSelector } from './TypeSelector';
import { Input } from './ui/input';
import { Badge } from './index';

const VisualizationPanel = ({
  activeTab,
  handleTabChange,
  chatType,
  setChatType,
  handleDataUpdate,
  handleRefresh,
  handleZoomIn,
  handleZoomOut,
  svgRef,
  createVisualization,
  data,
  visualizationType,
  setVisualizationType,
  sortBy,
  setSortBy,
  selectedCluster,
  handleTopicSelect,
  getColor
}) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [isFullscreen, setIsFullscreen] = useState(false);
  const containerRef = useRef(null);

  // Function to fit content to container
  const fitToContainer = useCallback(() => {
    if (!svgRef.current || !data) return;

    const svg = d3.select(svgRef.current);
    const container = containerRef.current;
    if (!container) return;

    const width = container.clientWidth;
    const height = container.clientHeight;
    const padding = 40;

    let bounds;
    if (visualizationType === 'islands') {
      // For islands visualization
      const clusters = svg.selectAll('.cluster');
      const clusterBounds = [];
      
      clusters.each(function() {
        const bbox = this.getBBox();
        const transform = d3.select(this).attr('transform');
        const translate = transform ? transform.match(/translate\(([-\d.]+),\s*([-\d.]+)\)/) : null;
        if (translate) {
          const x = parseFloat(translate[1]);
          const y = parseFloat(translate[2]);
          clusterBounds.push({
            x1: x,
            y1: y,
            x2: x + bbox.width,
            y2: y + bbox.height
          });
        }
      });

      if (clusterBounds.length) {
        bounds = {
          x1: d3.min(clusterBounds, d => d.x1),
          y1: d3.min(clusterBounds, d => d.y1),
          x2: d3.max(clusterBounds, d => d.x2),
          y2: d3.max(clusterBounds, d => d.y2)
        };
      }
    } else {
      // For star visualization
      const nodes = svg.selectAll('.node');
      const nodePositions = [];
      nodes.each(function(d) {
        const transform = d3.select(this).attr('transform');
        if (transform) {
          const translate = transform.match(/translate\(([-\d.]+),\s*([-\d.]+)\)/);
          if (translate) {
            nodePositions.push([parseFloat(translate[1]), parseFloat(translate[2])]);
          }
        }
      });

      if (nodePositions.length) {
        bounds = {
          x1: d3.min(nodePositions, d => d[0]),
          y1: d3.min(nodePositions, d => d[1]),
          x2: d3.max(nodePositions, d => d[0]),
          y2: d3.max(nodePositions, d => d[1])
        };
      }
    }

    if (!bounds) return;

    const boundsWidth = bounds.x2 - bounds.x1;
    const boundsHeight = bounds.y2 - bounds.y1;

    // Calculate the scale needed to fit the graph with padding
    const scale = Math.min(
      (width - padding * 2) / boundsWidth,
      (height - padding * 2) / boundsHeight
    ) * 0.9; // 90% of available space

    // Calculate translation to center the graph
    const translate = [
      width / 2 - ((bounds.x1 + boundsWidth / 2) * scale),
      height / 2 - ((bounds.y1 + boundsHeight / 2) * scale)
    ];

    // Create zoom behavior
    const zoom = d3.zoom()
      .scaleExtent([0.1, 8])
      .on("zoom", event => {
        svg.select('g').attr("transform", event.transform);
      });

    svg.call(zoom);

    // Apply transform with animation
    svg.transition()
      .duration(750)
      .call(
        zoom.transform,
        d3.zoomIdentity
          .translate(translate[0], translate[1])
          .scale(scale)
      );
  }, [data, visualizationType]);

  // Handle fullscreen changes
  useEffect(() => {
    const handleFullscreenChange = () => {
      const newFullscreenState = !!document.fullscreenElement;
      setIsFullscreen(newFullscreenState);
      
      // Wait for the fullscreen transition to complete
      setTimeout(() => {
        fitToContainer();
      }, 100);
    };

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
  }, [fitToContainer]);

  // Handle window resize
  useEffect(() => {
    const handleResize = () => {
      if (isFullscreen) {
        fitToContainer();
      }
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [isFullscreen, fitToContainer]);

  // Toggle fullscreen
  const toggleFullscreen = async () => {
    try {
      if (!isFullscreen) {
        await containerRef.current.requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    } catch (error) {
      console.error('Error toggling fullscreen:', error);
    }
  };

  // Search handler
  const handleSearch = useCallback((term) => {
    if (!data || !svgRef.current || !term) return;

    const svg = d3.select(svgRef.current);
    const width = svgRef.current.clientWidth;
    const height = svgRef.current.clientHeight;

    // Find matching node
    const allNodes = svg.selectAll('.node, .cluster');
    let matchingNode = null;

    allNodes.each(function(d) {
      const nodeData = d3.select(this).datum();
      if (nodeData && (
        (nodeData.title && nodeData.title.toLowerCase().includes(term.toLowerCase())) ||
        (nodeData.name && nodeData.name.toLowerCase().includes(term.toLowerCase()))
      )) {
        matchingNode = this;
      }
    });

    if (matchingNode) {
      const transform = d3.zoomTransform(matchingNode);
      const scale = 2;

      svg.transition()
        .duration(750)
        .call(
          d3.zoom().transform,
          d3.zoomIdentity
            .translate(width / 2 - transform.x * scale, height / 2 - transform.y * scale)
            .scale(scale)
        );
    }
  }, [data, svgRef]);

  const nodeStats = useMemo(() => {
    if (!data?.chartData?.[0]?.data) return { total: 0, clusters: 0, conversations: 0 };

    const conversations = data.chartData[0].data.length;
    const clusters = Object.keys(data.topics || {}).length;

    return {
      total: conversations + clusters,
      clusters,
      conversations
    };
  }, [data]);

  return (
    <div 
      ref={containerRef}
      className={`h-[85vh] w-full flex flex-col rounded-lg border border-border bg-background ${
        isFullscreen ? 'h-screen rounded-none border-none' : ''
      }`}
    >
      <div className="p-4 border-b border-border">
        <div className="relative">
          <Search className="absolute left-2 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
          <Input
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter') {
                handleSearch(searchTerm);
              }
            }}
            className="pl-8"
            placeholder="Search conversations and topics..."
          />
        </div>
      </div>

      <div className="flex-1 relative">
        <svg
          ref={svgRef}
          className="absolute inset-0 w-full h-full"
          preserveAspectRatio="xMidYMid meet"
        />
        <div className="absolute left-1/2 top-4 flex gap-2 z-10 -translate-x-1/2">
          <Badge variant="outline" className="h-6 bg-background/80 backdrop-blur">
            <span className="px-2 w-[100px] text-xs text-muted-foreground">Chats: {nodeStats.total}</span>
          </Badge>
          <Badge variant="outline" className="h-6 bg-background/80 backdrop-blur">
            <span className="px-2 w-[100px] text-xs text-muted-foreground">Topics: {nodeStats.clusters}</span>
          </Badge>
        </div>
      </div>

      <div className="p-4 border-t border-border space-y-3 bg-background">
        <div className="flex items-center justify-between gap-2">
          <VisualizationTypeSelector
            visualizationType={visualizationType}
            setVisualizationType={setVisualizationType}
          />
          <ChatTypeSelector
            chatType={chatType}
            setChatType={setChatType}
            onDataUpdate={handleDataUpdate}
          />
        </div>

        <div className="flex items-center justify-between gap-2">
          <Button size="sm" variant="outline" className="gap-2 flex-1" onClick={handleRefresh}>
            <RefreshCw className="h-3 w-3" />
            Refresh
          </Button>
          <div className="flex gap-1">
            <Button size="sm" variant="secondary" onClick={handleZoomOut}>
              <Minus className="h-3 w-3" />
            </Button>
            <Button size="sm" variant="secondary" onClick={handleZoomIn}>
              <Plus className="h-3 w-3" />
            </Button>
            <Button size="sm" variant="secondary" onClick={toggleFullscreen}>
              {isFullscreen ? (
                <Minimize2 className="h-3 w-3" />
              ) : (
                <Maximize2 className="h-3 w-3" />
              )}
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default VisualizationPanel;


// ========================================
// File: simplified-ui/src/components/VisualizationProvider.jsx
// ========================================

// VisualizationProvider.js
import React, { createContext, useContext, useState, useRef, useEffect, useCallback } from 'react';
import { useFPSMonitor } from './lib/utils'

const VisualizationContext = createContext(null);

export default function VisualizationProvider({ children }) {
  const [view, setView] = useState('clusters'); // 'clusters' or 'conversation'
  const [selectedConversation, setSelectedConversation] = useState(null);
  const [selectedNodePosition, setSelectedNodePosition] = useState(null);
  const [viewportDimensions, setViewportDimensions] = useState({ width: 0, height: 0 });
  const mainDashboardRef = useRef(null);
  const tangentChatRef = useRef(null);

  // Graph State
  const [graphData, setGraphData] = useState(null);
  const [isGraphLoading, setIsGraphLoading] = useState(true);

  // Existing States...
  const [transform, setTransform] = useState({
    scale: 1,
    translate: { x: 0, y: 0 }
  });

  // Smart Rendering States
  const [clusterPercentage, setClusterPercentage] = useState(1); // Start with 1%
  const [filteredData, setFilteredData] = useState(null);
  
  // FPS Monitoring
  const fps = useFPSMonitor();
  const TARGET_FPS = 45;

  // Handle refresh logic (implement as needed)
  const handleRefresh = () => {
    // Implement your refresh logic here, e.g., re-fetch data
    console.log('Refresh triggered');
  };

  // Theme state management
  const [theme, setTheme] = useState(() => {
    if (typeof window !== "undefined") {
      return localStorage.getItem("theme") || "light";
    }
    return "light";
  });

  useEffect(() => {
    document.documentElement.classList.remove('light', 'dark', 'hextech-nordic');
    document.documentElement.classList.add(theme);
    localStorage.setItem('theme', theme);
  }, [theme]);

  // Smart Rendering Effect
  useEffect(() => {
    if (!graphData) return;

    const totalClusters = Object.keys(graphData.topics).length;
    let currentPercentage = 1;

    const adjustRendering = () => {
      // Calculate the number of clusters to display
      const numClustersToShow = Math.ceil((currentPercentage / 100) * totalClusters);
      const clustersToShow = Object.keys(graphData.topics).slice(0, numClustersToShow);

      // Filter the data based on clusters to show
      const newFilteredData = {
        ...graphData,
        chartData: graphData.chartData.map(dataset => ({
          ...dataset,
          data: dataset.data.filter(d => clustersToShow.includes(d.cluster.toString()))
        })),
        topics: clustersToShow.reduce((acc, clusterId) => {
          acc[clusterId] = graphData.topics[clusterId];
          return acc;
        }, {})
      };

      setFilteredData(newFilteredData);
    };

    // Adjust cluster percentage based on FPS
    if (fps < TARGET_FPS && clusterPercentage < 100) {
      currentPercentage = clusterPercentage + 1;
      setClusterPercentage(currentPercentage);
    } else if (fps > TARGET_FPS + 10 && clusterPercentage > 1) { // Adding a buffer
      currentPercentage = clusterPercentage - 1;
      setClusterPercentage(currentPercentage);
    }

    adjustRendering();
  }, [fps, clusterPercentage, graphData]);

  const value = {
    view,
    setView,
    selectedConversation,
    setSelectedConversation,
    selectedNodePosition,
    setSelectedNodePosition,
    transform,
    setTransform,
    viewportDimensions,
    setViewportDimensions,
    mainDashboardRef,
    tangentChatRef,
    handleRefresh,
    theme,
    setTheme,
    graphData,
    setGraphData,
    isGraphLoading,
    setIsGraphLoading,
    clusterPercentage, // Expose clusterPercentage
    filteredData, // Expose filteredData
  };

  return (
    <VisualizationContext.Provider value={value}>
      {children}
    </VisualizationContext.Provider>
  );
}

export function useVisualization() {
  const context = useContext(VisualizationContext);
  if (!context) {
    throw new Error('useVisualization must be used within VisualizationProvider');
  }
  return context;
}



// ========================================
// File: simplified-ui/src/components/index.js
// ========================================

import React from 'react';

import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import * as SliderPrimitive from "@radix-ui/react-slider";
import * as SwitchPrimitive from "@radix-ui/react-switch";
import * as LabelPrimitive from "@radix-ui/react-label";

import { cn } from "./lib/utils";

// 1. Updated Slider Component
const Slider = React.forwardRef(({ className, min = 0, max = 100, step = 1, value = [0], onValueChange, ...props }, ref) => {
  return (
    <SliderPrimitive.Root
      ref={ref}
      className={cn("relative flex w-full touch-none select-none items-center", className)}
      min={min}
      max={max}
      step={step}
      value={value}
      onValueChange={onValueChange}
      {...props}
    >
      {/* Replaced hardcoded bg-secondary with theme variable */}
      <SliderPrimitive.Track className="relative h-1.5 w-full grow overflow-hidden rounded-full bg-secondary">
        {/* Replaced hardcoded bg-primary with theme variable */}
        <SliderPrimitive.Range className="absolute h-full bg-primary" />
      </SliderPrimitive.Track>
      <SliderPrimitive.Thumb
        className={cn(
          // Replaced bg-background with theme variable and border-primary with opacity for better contrast
          "block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors",
          "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring",
          "disabled:pointer-events-none disabled:opacity-50",
          "hover:bg-accent hover:border-primary"
        )}
      />
    </SliderPrimitive.Root>
  );
});

Slider.displayName = "Slider";

export { Slider };

// 2. Updated Card Components
export const Card = ({ children, className = '' }) => (
  // Replaced hardcoded bg-white and dark:bg-gray-800 with bg-card and text-card-foreground for theme adaptability
  <div className={`rounded-lg border bg-card text-card-foreground shadow ${className}`}>
    {children}
  </div>
);

export const CardHeader = ({ children, className = '' }) => (
  <div className={`flex flex-col space-y-1.5 p-6 ${className}`}>{children}</div>
);

export const CardTitle = ({ children, className = '' }) => (
  <h3 className={`font-semibold leading-none tracking-tight ${className}`}>{children}</h3>
);

export const CardContent = ({ children, className = '' }) => (
  <div className={`p-6 pt-0 ${className}`}>{children}</div>
);

export const CardDescription = ({ children, className = '' }) => (
  // Ensures text color adapts based on theme
  <p className={`text-sm text-muted-foreground ${className}`}>{children}</p>
);

// 3. Updated Button Component

export const Button = React.forwardRef(({
  children,
  variant = 'default',
  size = 'default',
  className = '',
  asChild = false,
  ...props
}, ref) => {
  const Comp = asChild ? 'div' : 'button';
  
  const variants = {
    default: 'bg-primary text-primary-foreground hover:bg-primary/90',
    destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
    outline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
    secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
    ghost: 'hover:bg-accent hover:text-accent-foreground',
    link: 'text-primary underline-offset-4 hover:underline'
  };

  const sizes = {
    default: 'h-10 px-4 py-2',
    sm: 'h-9 rounded-md px-3 text-sm',
    lg: 'h-11 rounded-md px-8 text-lg',
    icon: 'h-10 w-10 p-0'
  };

  return (
    <Comp
      ref={ref}
      className={`
        inline-flex items-center justify-center rounded-md text-sm font-medium 
        transition-colors focus-visible:outline-none focus-visible:ring-2 
        focus-visible:ring-ring focus-visible:ring-offset-2 
        disabled:pointer-events-none disabled:opacity-50 
        ${variants[variant]} 
        ${sizes[size]} 
        ${className}
      `}
      {...props}
    >
      {children}
    </Comp>
  );
});

// 4. Updated ScrollArea Component
export const ScrollArea = ({ children, className = '' }) => (
  <div className={`overflow-auto ${className}`}>{children}</div>
);

// 5. Updated Badge Component
export const Badge = ({ children, variant = 'default', className = '' }) => {
  const variants = {
    default: 'bg-primary text-primary-foreground',
    secondary: 'bg-secondary text-secondary-foreground',
    outline: 'border border-input',
  };

  return (
    <span className={cn(
      'inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-semibold transition-colors',
      variants[variant],
      className
    )}>
      {children}
    </span>
  );
};

// 6. Updated Input Component
export const Input = React.forwardRef(({ className = '', ...props }, ref) => (
  <input
    ref={ref}
    // Replaced hardcoded colors with theme variables
    className={`block w-full rounded-md border border-input bg-background px-3 py-2 text-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 ${className}`}
    {...props}
  />
));

// 7. Updated Progress Component
export const Progress = ({ value = 0, className = '' }) => (
  <div className={`relative h-4 w-full overflow-hidden rounded-full bg-secondary ${className}`}>
    {/* Replaced hardcoded bg-primary with theme variable */}
    <div
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </div>
);

// 8. Updated Separator Component
export const Separator = ({ className = '', ...props }) => (
  <div
    className={`my-4 h-px w-full bg-muted ${className}`}
    {...props}
  />
);


const Textarea = React.forwardRef(
  ({ className = '', disabled, ...props }, ref) => {
    return (
      <textarea
        ref={ref}
        disabled={disabled}
        className={cn(
          'flex h-24 w-full rounded-md border border-input bg-background px-3 py-2 text-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        {...props}
      />
    );
  }
);

Textarea.displayName = 'Textarea';

export { Textarea };

// 9. Updated Tooltip Components
const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    // Replaced hardcoded colors with theme variables
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

// 10. Updated Command Components
export const Command = ({ children, className = '' }) => (
  <div className={`flex items-center border rounded-md ${className}`}>
    {children}
  </div>
);

export const CommandInput = ({ className = '', ...props }) => (
  <input
    className={cn(
      'flex h-10 w-full rounded-md bg-transparent px-3 py-2 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50',
      className
    )}
    {...props}
  />
);

// 11. Updated DropdownMenu Components
export const DropdownMenu = ({ children }) => {
  const [open, setOpen] = React.useState(false);
  return React.Children.map(children, child =>
    React.cloneElement(child, { open, setOpen })
  );
};

export const DropdownMenuTrigger = ({ children, open, setOpen, asChild }) => {
  const Comp = asChild ? 'div' : 'button';
  return (
    <Comp onClick={() => setOpen(!open)}>
      {children}
    </Comp>
  );
};

export const DropdownMenuContent = ({ children, open, className = '', align = 'start', side = 'bottom' }) => {
  const [position, setPosition] = React.useState({ top: 0, left: 0 });
  const contentRef = React.useRef(null);

  React.useEffect(() => {
    if (!open) return;

    const triggerElement = contentRef.current?.previousElementSibling;
    if (!triggerElement) return;

    const triggerRect = triggerElement.getBoundingClientRect();

    let left = triggerRect.left;
    if (align === 'end') {
      left = triggerRect.right - (contentRef.current?.offsetWidth || 0);
    }

    let top = triggerRect.bottom + 4;
    if (side === 'top') {
      top = triggerRect.top - (contentRef.current?.offsetHeight || 0) - 4;
    }

    setPosition({ top, left });
  }, [open, align, side]);

  if (!open) return null;

  return (
    <div
      ref={contentRef}
      style={{
        position: 'fixed',
        top: position.top,
        left: position.left,
      }}
      // Replaced hardcoded bg-popover with theme variable
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover shadow-md',
        'animate-in fade-in-0 zoom-in-95',
        className
      )}
    >
      {/* Added max-height and overflow-auto */}
      <div className="max-w-[200px] max-h-[200px] overflow-auto py-1">
        {children}
      </div>
    </div>
  );
};

// Update DropdownMenuItem to handle active state and hover styles better
export const DropdownMenuItem = ({ children, className = '', active = false }) => (
  <button
    className={cn(
      'relative flex w-full cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none',
      // Replaced hardcoded hover and focus colors with theme variables
      'hover:bg-accent hover:text-accent-foreground',
      'focus:bg-accent focus:text-accent-foreground',
      active && 'bg-accent text-accent-foreground',
      className
    )}
  >
    {children}
  </button>
);

// 12. Updated Dialog Components
export const Dialog = ({ open, onOpenChange, children }) => {
  if (!open) return null;
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Replaced hardcoded bg-black/50 with theme variable bg-background/50 for overlay */}
      <div
        className="absolute inset-0 bg-background/50"
        onClick={() => onOpenChange(false)}
      ></div>
      {children}
    </div>
  );
};

export const DialogContent = ({ children, className = '' }) => (
  <div
    // Replaced hardcoded bg-white and dark:bg-gray-800 with bg-card and text-card-foreground
    className={`relative z-50 w-full max-w-md rounded-lg bg-card text-card-foreground p-6 shadow-lg ${className}`}
  >
    {children}
  </div>
);

export const DialogHeader = ({ children, className = '' }) => (
  <div className={`mb-4 ${className}`}>{children}</div>
);

export const DialogTitle = ({ children, className = '' }) => (
  <h2 className={`text-lg font-semibold ${className}`}>{children}</h2>
);

export const DialogDescription = ({ children, className = '' }) => (
  <div className={`text-sm text-muted-foreground ${className}`}>{children}</div>
);

export const DialogFooter = ({ children, className = '' }) => (
  <div className={`mt-4 flex justify-end space-x-2 ${className}`}>{children}</div>
);

const Label = React.forwardRef(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(
      "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
      className
    )}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

// Switch Component
const Switch = React.forwardRef(({ className, ...props }, ref) => (
  <SwitchPrimitive.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitive.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitive.Root>
));
Switch.displayName = SwitchPrimitive.Root.displayName;

export { Label, Switch };


// ========================================
// File: simplified-ui/src/components/lib/utils.js
// ========================================

// src/lib/utils.js
import { clsx } from "clsx"
import { twMerge } from "tailwind-merge"
import { useState, useEffect, useRef } from 'react';


export const useFPSMonitor = () => {
  const [fps, setFps] = useState(60);
  const frameCount = useRef(0);
  const lastTime = useRef(performance.now());

  useEffect(() => {
    const interval = 1000; // 1 second
    const update = () => {
      const now = performance.now();
      const delta = now - lastTime.current;
      const currentFps = (frameCount.current / delta) * 1000;
      setFps(currentFps);
      frameCount.current = 0;
      lastTime.current = now;
    };

    const raf = () => {
      frameCount.current += 1;
      requestAnimationFrame(raf);
    };

    const fpsInterval = setInterval(update, interval);
    requestAnimationFrame(raf);

    return () => {
      clearInterval(fpsInterval);
    };
  }, []);

  return fps;
};


export function cn(...inputs) {
  return twMerge(clsx(inputs))
}



// ========================================
// File: simplified-ui/src/components/ui/alert.jsx
// ========================================

import * as React from "react";
import { cn } from "../../utils/utils";
const Alert = React.forwardRef(({ className, variant = "default", ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(
      "relative w-full rounded-lg border p-4",
      {
        "bg-background text-foreground": variant === "default",
        "border-destructive/50 text-destructive dark:border-destructive": variant === "destructive",
      },
      className
    )}
    {...props}
  />
));
Alert.displayName = "Alert";

const AlertDescription = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("mt-1 text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertDescription };


// ========================================
// File: simplified-ui/src/components/ui/button.jsx
// ========================================

import * as React from "react"
import { cn } from "../../utils/utils";
const Button = React.forwardRef(({
  className,
  variant = "default",
  size = "default",
  children,
  ...props
}, ref) => {
  const baseStyles = "inline-flex items-center justify-center rounded-md font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50"
  
  const variants = {
    default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
    destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
    outline: "border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground",
    secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
    ghost: "hover:bg-accent hover:text-accent-foreground",
    link: "text-primary underline-offset-4 hover:underline",
  }

  const sizes = {
    default: "h-9 px-4 py-2",
    sm: "h-8 rounded-md px-3 text-xs",
    lg: "h-10 rounded-md px-8",
    icon: "h-9 w-9",
  }

  return (
    <button
      className={cn(
        baseStyles,
        variants[variant],
        sizes[size],
        className
      )}
      ref={ref}
      {...props}
    >
      {children}
    </button>
  )
})
Button.displayName = "Button"

export { Button }


// ========================================
// File: simplified-ui/src/components/ui/card.jsx
// ========================================

// src/components/ui/card.jsx
import * as React from "react"

const Card = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={`rounded-lg border bg-card text-card-foreground shadow-sm ${className}`}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={`flex flex-col space-y-1.5 p-6 ${className}`}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={`text-2xl font-semibold leading-none tracking-tight ${className}`}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={`text-sm text-muted-foreground ${className}`}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef(({ className, ...props }, ref) => (
  <div ref={ref} className={`p-6 pt-0 ${className}`} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={`flex items-center p-6 pt-0 ${className}`}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


// ========================================
// File: simplified-ui/src/components/ui/command.jsx
// ========================================

import * as React from "react";
import { cn } from "../../utils/utils";
const Command = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
));
Command.displayName = "Command";

const CommandInput = React.forwardRef(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3">
    <input
      ref={ref}
      type="search"
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none",
        "placeholder:text-muted-foreground disabled:cursor-not-allowed",
        "disabled:opacity-50 focus:ring-0",
        className
      )}
      {...props}
    />
  </div>
));
CommandInput.displayName = "CommandInput";

const CommandList = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
));
CommandList.displayName = "CommandList";

const CommandEmpty = React.forwardRef(({ children, ...props }, ref) => (
  <div
    ref={ref}
    className="py-6 text-center text-sm text-muted-foreground"
    {...props}
  >
    {children}
  </div>
));
CommandEmpty.displayName = "CommandEmpty";

export { Command, CommandInput, CommandList, CommandEmpty };


// ========================================
// File: simplified-ui/src/components/ui/dialog.jsx
// ========================================

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import { cn } from "../../utils/utils";
const Dialog = DialogPrimitive.Root;
const DialogTrigger = DialogPrimitive.Trigger;
const DialogPortal = DialogPrimitive.Portal;
const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({ className, ...props }) => (
  <div className={cn("flex flex-col space-y-1.5 text-center sm:text-left", className)} {...props} />
);
DialogHeader.displayName = "DialogHeader";

const DialogTitle = React.forwardRef(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogClose,
};


// ========================================
// File: simplified-ui/src/components/ui/dropdown-menu.jsx
// ========================================

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { cn } from "../../utils/utils";
const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuContent = React.forwardRef(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      align="start"
      side="top"
      className={cn(
        "absolute z-[9999] min-w-[8rem] overflow-visible rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out",
        "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        "data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
        "data-[side=bottom]:slide-in-from-top-2",
        "data-[side=top]:slide-in-from-bottom-2",
        "data-[side=left]:slide-in-from-right-2",
        "data-[side=right]:slide-in-from-left-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
};


// ========================================
// File: simplified-ui/src/components/ui/input.jsx
// ========================================

import * as React from "react";
import { cn } from "../../utils/utils";
const Input = React.forwardRef(({ className, type, ...props }, ref) => {
  return (
    <input
      type={type}
      className={cn(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2",
        "text-sm ring-offset-background file:border-0 file:bg-transparent",
        "file:text-sm file:font-medium placeholder:text-muted-foreground",
        "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring",
        "focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      ref={ref}
      {...props}
    />
  );
});

Input.displayName = "Input";

export { Input };


// ========================================
// File: simplified-ui/src/components/ui/progress.jsx
// ========================================


// Progress.jsx
import * as React from "react"
import { cn } from "../lib/utils"

const Progress = React.forwardRef(({ 
  className,
  value,
  max = 100,
  ...props 
}, ref) => {
  return (
    <div
      ref={ref}
      role="progressbar"
      aria-valuemax={max}
      aria-valuenow={value}
      aria-valuemin={0}
      className={cn(
        "relative h-2 w-full overflow-hidden rounded-full bg-secondary",
        className
      )}
      {...props}
    >
      <div
        className="h-full w-full flex-1 bg-primary transition-all"
        style={{
          transform: `translateX(-${100 - (value || 0)}%)`,
        }}
      />
    </div>
  )
})
Progress.displayName = "Progress"


// ========================================
// File: simplified-ui/src/components/ui/scroll-area.jsx
// ========================================

import * as React from "react";
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";
import { cn } from "../../utils/utils";
const ScrollArea = React.forwardRef(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };


// ========================================
// File: simplified-ui/src/components/ui/select.jsx
// ========================================

import React, { useState, useEffect, useRef } from "react";
import { ChevronDown } from 'lucide-react';
import { cn } from "../../utils/utils";
const SelectContext = React.createContext();

export const Select = ({ children, value, onValueChange, disabled = false }) => {
    const [open, setOpen] = useState(false);
    const selectRef = useRef(null);

    useEffect(() => {
        const handleClickOutside = (event) => {
            if (selectRef.current && !selectRef.current.contains(event.target)) {
                setOpen(false);
            }
        };

        const handleEscape = (event) => {
            if (event.key === 'Escape') {
                setOpen(false);
            }
        };

        document.addEventListener('mousedown', handleClickOutside);
        document.addEventListener('keydown', handleEscape);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
            document.removeEventListener('keydown', handleEscape);
        };
    }, []);

    const handleChange = (newValue) => {
        onValueChange?.(newValue);
        setOpen(false);
    };

    return (
        <SelectContext.Provider value={{ value, onValueChange: handleChange, open, setOpen, disabled }}>
            <div ref={selectRef} className="relative">
                {React.Children.map(children, (child) => {
                    if (!React.isValidElement(child)) return child;

                    if (child.type.displayName === 'SelectTrigger') {
                        return React.cloneElement(child, {
                            open,
                            setOpen,
                            disabled,
                        });
                    }

                    if (child.type.displayName === 'SelectContent') {
                        return React.cloneElement(child, {
                            open,
                            children: React.Children.map(child.props.children, (childItem) => {
                                if (!React.isValidElement(childItem)) return childItem;

                                if (childItem.type.displayName === 'SelectItem') {
                                    return React.cloneElement(childItem, {
                                        onChange: handleChange,
                                        currentValue: value,
                                    });
                                }

                                return childItem;
                            }),
                        });
                    }

                    return child;
                })}
            </div>
        </SelectContext.Provider>
    );
};

export const SelectTrigger = ({ children, className = '', 'aria-label': ariaLabel }) => {
    const { open, setOpen, disabled } = React.useContext(SelectContext);
    return (
        <button
            type="button"
            onClick={() => !disabled && setOpen(!open)}
            className={cn(
                "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground",
                "focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
                "disabled:cursor-not-allowed disabled:opacity-50",
                "hover:bg-accent/50",
                className
            )}
            disabled={disabled}
            aria-haspopup="listbox"
            aria-expanded={open}
            aria-label={ariaLabel}
        >
            {children}
            <ChevronDown className={cn(
                "ml-2 h-4 w-4 opacity-50 transition-transform duration-200",
                open && "rotate-180"
            )} />
        </button>
    );
}

export const SelectContent = ({
    children,
    open,
    className = ''
}) => {
    if (!open) return null;

    return (
        <div
            className={cn(
                "absolute z-50 min-w-[8rem] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md",
                "animate-in fade-in-0 zoom-in-95",
                "mt-1",
                className
            )}
            role="listbox"
        >
            <div className="max-h-[200px] overflow-auto p-1 scrollbar-thin scrollbar-thumb-accent">
                {children}
            </div>
        </div>
    );
};

export const SelectItem = ({ children, value, className = '', disabled = false, onChange }) => {
    const { onValueChange, value: currentValue } = React.useContext(SelectContext);
    return (
        <button
            type="button"
            onClick={() => !disabled && onValueChange?.(value)}
            className={cn(
                "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 px-2 text-sm outline-none",
                "hover:bg-accent hover:text-accent-foreground",
                "focus:bg-accent focus:text-accent-foreground",
                "data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
                currentValue === value && "bg-accent text-accent-foreground",
                className
            )}
            role="option"
            aria-selected={currentValue === value}
            data-disabled={disabled}
        >
            {children}
        </button>
    );
}

export const SelectValue = ({
    children,
    value,
    placeholder,
    className = ''
}) => {
    if (!children && !value) {
        return (
            <span className={cn("text-muted-foreground", className)}>
                {placeholder}
            </span>
        );
    }

    return (
        <span className={cn("text-sm", className)}>
            {children || value}
        </span>
    );
};

Select.displayName = 'Select';
SelectTrigger.displayName = 'SelectTrigger';
SelectContent.displayName = 'SelectContent';
SelectItem.displayName = 'SelectItem';
SelectValue.displayName = 'SelectValue';



// ========================================
// File: simplified-ui/src/components/ui/tabs.jsx
// ========================================

import React, {

} from "react";

import { cn } from "../../utils/utils";

// Keep your existing TabsContext and related components here
const TabsContext = React.createContext();


export const Tabs = ({
    children,
    value: valueProp,
    defaultValue,
    onValueChange,
    className = "",
}) => {
    const [internalValue, setInternalValue] = React.useState(defaultValue);
    const value = valueProp !== undefined ? valueProp : internalValue;
    const setValue =
        onValueChange !== undefined ? onValueChange : setInternalValue;

    const contextValue = React.useMemo(
        () => ({ value, setValue }),
        [value, setValue]
    );

    return (
        <TabsContext.Provider value={contextValue}>
            <div className={className}>{children}</div>
        </TabsContext.Provider>
    );
};

export const TabsList = ({ children, className = "" }) => (
    <div
        className={`inline-flex h-10 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground ${className}`}
    >
        {children}
    </div>
);

export const TabsTrigger = ({ children, value, className = "" }) => {
    const { value: selectedValue, setValue } = React.useContext(TabsContext);
    const isActive = value === selectedValue;

    return (
        <button
            className={cn(
                "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
                isActive ? "bg-background text-foreground shadow-sm" : "",
                className
            )}
            onClick={() => setValue(value)}
        >
            {children}
        </button>
    );
};

export const TabsContent = ({ children, value, className = "" }) => {
    const { value: selectedValue } = React.useContext(TabsContext);

    if (value !== selectedValue) {
        return null;
    }

    return (
        <div
            className={cn(
                "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
                className
            )}
        >
            {children}
        </div>
    );
};



// ========================================
// File: simplified-ui/src/components/ui/tooltip.jsx
// ========================================

import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import { cn } from "../../utils/utils";
const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

